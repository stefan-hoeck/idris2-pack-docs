<!DOCTYPE html><html lang="en">
<head>
  <meta charset="utf-8">
  <title>Language.Reflection.Refined</title>
  <link rel="stylesheet" type="text/css" id="preferredStyle" href="../default.css">
  <script>
    /* Updates the stylesheet to use the preferred one.
       Note that we set the link to root ++ sourceLoc because the config
       is shared across the whole website, so the root may differ from
       page to page.
    */
    function setStyleSource (sourceLoc) {
      document.getElementById("preferredStyle").href = "../" + sourceLoc + ".css";
      document.getElementById("selectPreferredStyle").value = sourceLoc;
    }
    /* Initialises the preferred style sheet:
       1. if there is a stored value then use that
          otherwise select the default
       2. set both the css link href & the drop down menu selected option
    */
    function initStyleSource () {
      var preferredStyle = localStorage.getItem("stylefile");
      if (preferredStyle !== null) {
        setStyleSource(preferredStyle);
      } else {
        setStyleSource("default");
      };
    }
    function saveStyleSource (preferredStyle) {
      localStorage.stylefile = preferredStyle;
    }
    </script>
</head>
<body class="namespace">
<header>
  <strong>Idris2Doc</strong> : Language.Reflection.Refined
  <nav><a href="../index.html">Index</a>
  <select id="selectPreferredStyle">
    <option value="default">Default</option>
<option value="alternative">Alternative</option>
<option value="blackandwhite">Black & White</option>

  </select>
  </nav>
  <script>
  /* We start by initialising the style source */
  initStyleSource();
  /* This listens for changes on the drop down menu and updates the
     css used for the current page when a selection is made.
  */
  document.getElementById("selectPreferredStyle").addEventListener("change", function(){
    var selected = this.options[this.selectedIndex].value; /* the option chosen */
    setStyleSource (selected);
    saveStyleSource (selected);
  });
</script>
</header>
<div class="container"><div id="module-header"><h1>Language.Reflection.Refined</h1><span style="float:right">(<a href="Language.Reflection.Refined.src.html">source</a>)</span><pre>The content of this module is based on the
tutorial post about [refined primitives](../../Doc/Primitives.md).
</pre></div><h2>Reexports</h2><code><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Language.Reflection.Refined.Util<br><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Language.Reflection.Derive</code><h2>Definitions</h2><dl class="decls"><dt id="Language.Reflection.Refined.refinedEq"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedEq"><span class="name function">refinedEq</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  Creates&ensp;an&ensp;`Eq`&ensp;implementation&ensp;for&ensp;the&ensp;given&ensp;datatype<br>  by&ensp;using&ensp;the&ensp;given&ensp;accessor&ensp;function.<br>  <br>  This&ensp;is&ensp;hardly&ensp;useful&ensp;on&ensp;its&ensp;own&ensp;but&ensp;convenient&ensp;when<br>  combined&ensp;with&ensp;other&ensp;interface&ensp;implementors.<br>  <br>  In&ensp;some&ensp;occasions&ensp;it&ensp;is&ensp;useful&ensp;to&ensp;have&ensp;one&ensp;or&ensp;several<br>  phantom&ensp;types&ensp;for&ensp;the&ensp;refined&ensp;type.&ensp;Therefore,&ensp;the&ensp;exact<br>  type&ensp;should&ensp;be&ensp;given&ensp;as&ensp;a&ensp;`TTImp`.<br>  <br>  ```idris&ensp;example<br>  record&ensp;AtomicNr&ensp;a&ensp;where<br>  constructor&ensp;MkAtomicNr<br>  value&ensp;:&ensp;Int<br>  0&ensp;inBounds&ensp;:&ensp;So&ensp;(1&ensp;&lt;=&ensp;value&ensp;&amp;&amp;&ensp;value&ensp;&lt;=&ensp;118)<br>  <br>  %runElab&ensp;refinedEq&ensp;&quot;AtomicNr&quot;&ensp;`(AtomicNr&ensp;a)&ensp;`{{value}}<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Refined.refinedOrd"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedOrd"><span class="name function">refinedOrd</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  Creates&ensp;an&ensp;`Ord`&ensp;implementation&ensp;for&ensp;the&ensp;given&ensp;datatype<br>  by&ensp;using&ensp;the&ensp;given&ensp;accessor&ensp;function.<br>  <br>  This&ensp;is&ensp;hardly&ensp;useful&ensp;on&ensp;its&ensp;own&ensp;but&ensp;convenient&ensp;when<br>  combined&ensp;with&ensp;other&ensp;interface&ensp;implementors.<br>  <br>  ```idris&ensp;example<br>  record&ensp;AtomicNr&ensp;a&ensp;where<br>  constructor&ensp;MkAtomicNr<br>  value&ensp;:&ensp;Int<br>  0&ensp;inBounds&ensp;:&ensp;So&ensp;(1&ensp;&lt;=&ensp;value&ensp;&amp;&amp;&ensp;value&ensp;&lt;=&ensp;118)<br>  <br>  %runElab&ensp;refinedOrd&ensp;&quot;AtomicNr&quot;&ensp;`(AtomicNr&ensp;a)&ensp;`{{value}}<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Refined.refinedShow"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedShow"><span class="name function">refinedShow</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  Creates&ensp;a&ensp;`Show`&ensp;implementation&ensp;for&ensp;the&ensp;given&ensp;datatype<br>  by&ensp;using&ensp;the&ensp;given&ensp;accessor&ensp;function.<br>  <br>  This&ensp;is&ensp;hardly&ensp;useful&ensp;on&ensp;its&ensp;own&ensp;but&ensp;convenient&ensp;when<br>  combined&ensp;with&ensp;other&ensp;interface&ensp;implementors.<br>  <br>  ```idris&ensp;example<br>  record&ensp;AtomicNr&ensp;a&ensp;where<br>  constructor&ensp;MkAtomicNr<br>  value&ensp;:&ensp;Int<br>  0&ensp;inBounds&ensp;:&ensp;So&ensp;(1&ensp;&lt;=&ensp;value&ensp;&amp;&amp;&ensp;value&ensp;&lt;=&ensp;118)<br>  <br>  %runElab&ensp;refinedShow&ensp;&quot;AtomicNr&quot;&ensp;`(AtomicNr&ensp;a)&ensp;`{{value}}<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Refined.refinedEqOrdShow"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedEqOrdShow"><span class="name function">refinedEqOrdShow</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  Convenience&ensp;function&ensp;combining&ensp;`refinedEq`,&ensp;`refinedOrd`,<br>  and&ensp;`refinedShow`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Refined.refinedIntegral"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedIntegral"><span class="name function">refinedIntegral</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  This&ensp;creates&ensp;`Eq`,&ensp;`Ord`,&ensp;and&ensp;`Show`&ensp;implementations&ensp;as<br>  well&ensp;as&ensp;conversion&ensp;functions&ensp;for&ensp;a&ensp;refined&ensp;integral&ensp;number.<br>  <br>  Conversion&ensp;functions&ensp;are&ensp;called&ensp;`refine`&ensp;and&ensp;`fromInteger`<br>  and&ensp;are&ensp;put&ensp;in&ensp;their&ensp;own&ensp;namespace,&ensp;named&ensp;after&ensp;the<br>  data&ensp;type&apos;s&ensp;name.<br>  <br>  ```idris&ensp;example<br>  record&ensp;AtomicNr&ensp;a&ensp;where<br>  constructor&ensp;MkAtomicNr<br>  value&ensp;:&ensp;Int<br>  0&ensp;inBounds&ensp;:&ensp;So&ensp;(1&ensp;&lt;=&ensp;value&ensp;&amp;&amp;&ensp;value&ensp;&lt;=&ensp;118)<br>  <br>  %runElab&ensp;refinedIntegral&ensp;&quot;AtomicNr&quot;<br>  `(AtomicNr&ensp;a)<br>  `{{MkAtomicNr}}<br>  `{{value}}<br>  `(Int)<br>  ```<br>  <br>  The&ensp;above&ensp;will&ensp;result&ensp;in&ensp;the&ensp;following&ensp;declarations&ensp;being&ensp;generated:<br>  <br>  ```idris&ensp;example<br>  Eq&ensp;AtomicNr&ensp;where<br>  (==)&ensp;=&ensp;(==)&ensp;`on`&ensp;value<br>  <br>  Ord&ensp;AtomicNr&ensp;where<br>  compare&ensp;=&ensp;compare&ensp;`on`&ensp;value<br>  <br>  Show&ensp;AtomicNr&ensp;where<br>  showPrec&ensp;p&ensp;=&ensp;showPrec&ensp;p&ensp;.&ensp;value<br>  <br>  namespace&ensp;AtomicNr<br>  refine&ensp;:&ensp;Int&ensp;-&gt;&ensp;Maybe&ensp;AtomicNr<br>  refine&ensp;=&ensp;refineSo&ensp;MkAtomicNr<br>  <br>  fromInteger&ensp;:&ensp;(v&ensp;:&ensp;Integer)<br>  -&gt;&ensp;{auto&ensp;0&ensp;_:&ensp;IsJust&ensp;(refine&ensp;$&ensp;fromInteger&ensp;v)}<br>  -&gt;&ensp;AtomicNr<br>  fromInteger&ensp;v&ensp;=&ensp;fromJust&ensp;(refine&ensp;$&ensp;fromInteger&ensp;v)<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Refined.refinedIntegralDflt"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedIntegralDflt"><span class="name function">refinedIntegralDflt</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Refined.refinedInt"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedInt"><span class="name function">refinedInt</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  Specialized&ensp;version&ensp;of&ensp;`refinedIntegral`&ensp;for&ensp;data&ensp;types,<br>  which&ensp;adhere&ensp;to&ensp;the&ensp;following&ensp;conventions:<br>  <br>  *&ensp;If&ensp;a&ensp;data&ensp;type&apos;s&ensp;name&ensp;is&ensp;`Foo`&ensp;its&ensp;constructor&ensp;is&ensp;named&ensp;`MkFoo`.<br>  *&ensp;The&ensp;field&ensp;accessor&ensp;of&ensp;the&ensp;wrapped&ensp;Int&ensp;is&ensp;named&ensp;`value`.<br>  *&ensp;The&ensp;proof&ensp;of&ensp;validity&ensp;consists&ensp;of&ensp;a&ensp;single&ensp;zero&ensp;quantity&ensp;`So`.<br>  <br>  ```idris&ensp;example<br>  record&ensp;AtomicNr&ensp;where<br>  constructor&ensp;MkAtomicNr<br>  value&ensp;:&ensp;Int<br>  0&ensp;inBounds&ensp;:&ensp;So&ensp;(1&ensp;&lt;=&ensp;value&ensp;&amp;&amp;&ensp;value&ensp;&lt;=&ensp;118)<br>  <br>  %runElab&ensp;refinedInt&ensp;&quot;AtomicNr&quot;<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Refined.refinedBits8"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedBits8"><span class="name function">refinedBits8</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  Specialized&ensp;version&ensp;of&ensp;`refinedIntegral`&ensp;for&ensp;data&ensp;types,<br>  which&ensp;adhere&ensp;to&ensp;the&ensp;following&ensp;conventions:<br>  <br>  *&ensp;If&ensp;a&ensp;data&ensp;type&apos;s&ensp;name&ensp;is&ensp;`Foo`&ensp;its&ensp;constructor&ensp;is&ensp;named&ensp;`MkFoo`.<br>  *&ensp;The&ensp;field&ensp;accessor&ensp;of&ensp;the&ensp;wrapped&ensp;Int&ensp;is&ensp;named&ensp;`value`.<br>  *&ensp;The&ensp;proof&ensp;of&ensp;validity&ensp;consists&ensp;of&ensp;a&ensp;single&ensp;zero&ensp;quantity&ensp;`So`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Refined.refinedBits16"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedBits16"><span class="name function">refinedBits16</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  Specialized&ensp;version&ensp;of&ensp;`refinedIntegral`&ensp;for&ensp;data&ensp;types,<br>  which&ensp;adhere&ensp;to&ensp;the&ensp;following&ensp;conventions:<br>  <br>  *&ensp;If&ensp;a&ensp;data&ensp;type&apos;s&ensp;name&ensp;is&ensp;`Foo`&ensp;its&ensp;constructor&ensp;is&ensp;named&ensp;`MkFoo`.<br>  *&ensp;The&ensp;field&ensp;accessor&ensp;of&ensp;the&ensp;wrapped&ensp;Int&ensp;is&ensp;named&ensp;`value`.<br>  *&ensp;The&ensp;proof&ensp;of&ensp;validity&ensp;consists&ensp;of&ensp;a&ensp;single&ensp;zero&ensp;quantity&ensp;`So`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Refined.refinedBits32"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedBits32"><span class="name function">refinedBits32</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  Specialized&ensp;version&ensp;of&ensp;`refinedIntegral`&ensp;for&ensp;data&ensp;types,<br>  which&ensp;adhere&ensp;to&ensp;the&ensp;following&ensp;conventions:<br>  <br>  *&ensp;If&ensp;a&ensp;data&ensp;type&apos;s&ensp;name&ensp;is&ensp;`Foo`&ensp;its&ensp;constructor&ensp;is&ensp;named&ensp;`MkFoo`.<br>  *&ensp;The&ensp;field&ensp;accessor&ensp;of&ensp;the&ensp;wrapped&ensp;Int&ensp;is&ensp;named&ensp;`value`.<br>  *&ensp;The&ensp;proof&ensp;of&ensp;validity&ensp;consists&ensp;of&ensp;a&ensp;single&ensp;zero&ensp;quantity&ensp;`So`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Refined.refinedBits64"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedBits64"><span class="name function">refinedBits64</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  Specialized&ensp;version&ensp;of&ensp;`refinedIntegral`&ensp;for&ensp;data&ensp;types,<br>  which&ensp;adhere&ensp;to&ensp;the&ensp;following&ensp;conventions:<br>  <br>  *&ensp;If&ensp;a&ensp;data&ensp;type&apos;s&ensp;name&ensp;is&ensp;`Foo`&ensp;its&ensp;constructor&ensp;is&ensp;named&ensp;`MkFoo`.<br>  *&ensp;The&ensp;field&ensp;accessor&ensp;of&ensp;the&ensp;wrapped&ensp;Int&ensp;is&ensp;named&ensp;`value`.<br>  *&ensp;The&ensp;proof&ensp;of&ensp;validity&ensp;consists&ensp;of&ensp;a&ensp;single&ensp;zero&ensp;quantity&ensp;`So`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Refined.refinedInt8"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedInt8"><span class="name function">refinedInt8</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  Specialized&ensp;version&ensp;of&ensp;`refinedIntegral`&ensp;for&ensp;data&ensp;types,<br>  which&ensp;adhere&ensp;to&ensp;the&ensp;following&ensp;conventions:<br>  <br>  *&ensp;If&ensp;a&ensp;data&ensp;type&apos;s&ensp;name&ensp;is&ensp;`Foo`&ensp;its&ensp;constructor&ensp;is&ensp;named&ensp;`MkFoo`.<br>  *&ensp;The&ensp;field&ensp;accessor&ensp;of&ensp;the&ensp;wrapped&ensp;Int&ensp;is&ensp;named&ensp;`value`.<br>  *&ensp;The&ensp;proof&ensp;of&ensp;validity&ensp;consists&ensp;of&ensp;a&ensp;single&ensp;zero&ensp;quantity&ensp;`So`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Refined.refinedInt16"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedInt16"><span class="name function">refinedInt16</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  Specialized&ensp;version&ensp;of&ensp;`refinedIntegral`&ensp;for&ensp;data&ensp;types,<br>  which&ensp;adhere&ensp;to&ensp;the&ensp;following&ensp;conventions:<br>  <br>  *&ensp;If&ensp;a&ensp;data&ensp;type&apos;s&ensp;name&ensp;is&ensp;`Foo`&ensp;its&ensp;constructor&ensp;is&ensp;named&ensp;`MkFoo`.<br>  *&ensp;The&ensp;field&ensp;accessor&ensp;of&ensp;the&ensp;wrapped&ensp;Int&ensp;is&ensp;named&ensp;`value`.<br>  *&ensp;The&ensp;proof&ensp;of&ensp;validity&ensp;consists&ensp;of&ensp;a&ensp;single&ensp;zero&ensp;quantity&ensp;`So`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Refined.refinedInt32"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedInt32"><span class="name function">refinedInt32</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  Specialized&ensp;version&ensp;of&ensp;`refinedIntegral`&ensp;for&ensp;data&ensp;types,<br>  which&ensp;adhere&ensp;to&ensp;the&ensp;following&ensp;conventions:<br>  <br>  *&ensp;If&ensp;a&ensp;data&ensp;type&apos;s&ensp;name&ensp;is&ensp;`Foo`&ensp;its&ensp;constructor&ensp;is&ensp;named&ensp;`MkFoo`.<br>  *&ensp;The&ensp;field&ensp;accessor&ensp;of&ensp;the&ensp;wrapped&ensp;Int&ensp;is&ensp;named&ensp;`value`.<br>  *&ensp;The&ensp;proof&ensp;of&ensp;validity&ensp;consists&ensp;of&ensp;a&ensp;single&ensp;zero&ensp;quantity&ensp;`So`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Refined.refinedInt64"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedInt64"><span class="name function">refinedInt64</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  Specialized&ensp;version&ensp;of&ensp;`refinedIntegral`&ensp;for&ensp;data&ensp;types,<br>  which&ensp;adhere&ensp;to&ensp;the&ensp;following&ensp;conventions:<br>  <br>  *&ensp;If&ensp;a&ensp;data&ensp;type&apos;s&ensp;name&ensp;is&ensp;`Foo`&ensp;its&ensp;constructor&ensp;is&ensp;named&ensp;`MkFoo`.<br>  *&ensp;The&ensp;field&ensp;accessor&ensp;of&ensp;the&ensp;wrapped&ensp;Int&ensp;is&ensp;named&ensp;`value`.<br>  *&ensp;The&ensp;proof&ensp;of&ensp;validity&ensp;consists&ensp;of&ensp;a&ensp;single&ensp;zero&ensp;quantity&ensp;`So`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Refined.refinedFloating"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedFloating"><span class="name function">refinedFloating</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  This&ensp;creates&ensp;`Eq`,&ensp;`Ord`,&ensp;and&ensp;`Show`&ensp;implementations&ensp;as<br>  well&ensp;as&ensp;conversion&ensp;functions&ensp;for&ensp;a&ensp;refined&ensp;floating&ensp;point<br>  number.<br>  <br>  Conversion&ensp;functions&ensp;are&ensp;called&ensp;`refine`&ensp;and&ensp;`fromDouble`<br>  and&ensp;are&ensp;put&ensp;in&ensp;their&ensp;own&ensp;namespace,&ensp;named&ensp;after&ensp;the<br>  data&ensp;type&apos;s&ensp;name.<br>  <br>  ```idris&ensp;example<br>  record&ensp;Abundance&ensp;a&ensp;where<br>  constructor&ensp;MkAbundance<br>  value&ensp;:&ensp;Double<br>  0&ensp;inBounds&ensp;:&ensp;So&ensp;(0&ensp;<&ensp;value&ensp;&amp;&amp;&ensp;value&ensp;&lt;=&ensp;1)<br>  <br>  %runElab&ensp;refinedFloating&ensp;&quot;Abundance&quot;&ensp;`(Abundance&ensp;a)&ensp;`{{MkAbundance}}&ensp;`{{value}}<br>  ```<br>  <br>  The&ensp;above&ensp;will&ensp;result&ensp;in&ensp;the&ensp;following&ensp;declarations&ensp;being&ensp;generated:<br>  <br>  ```idris&ensp;example<br>  Eq&ensp;Abundance&ensp;where<br>  (==)&ensp;=&ensp;(==)&ensp;`on`&ensp;value<br>  <br>  Ord&ensp;Abundance&ensp;where<br>  compare&ensp;=&ensp;compare&ensp;`on`&ensp;value<br>  <br>  Show&ensp;Abundance&ensp;where<br>  showPrec&ensp;p&ensp;=&ensp;showPrec&ensp;p&ensp;.&ensp;value<br>  <br>  namespace&ensp;Abundance<br>  refine&ensp;:&ensp;Double&ensp;-&gt;&ensp;Maybe&ensp;Abundance<br>  refine&ensp;=&ensp;refineSo&ensp;MkAbundance<br>  <br>  fromDouble&ensp;:&ensp;(v&ensp;:&ensp;Double)<br>  -&gt;&ensp;{auto&ensp;0&ensp;_:&ensp;IsJust&ensp;(refine&ensp;v)}<br>  -&gt;&ensp;Abundance<br>  fromDouble&ensp;v&ensp;=&ensp;fromJust&ensp;(refine&ensp;v)<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Refined.refinedDouble"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedDouble"><span class="name function">refinedDouble</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  Convenience&ensp;version&ensp;of&ensp;`refinedFloating`&ensp;for&ensp;data&ensp;types,<br>  which&ensp;adhere&ensp;to&ensp;the&ensp;following&ensp;conventions:<br>  <br>  *&ensp;If&ensp;a&ensp;data&ensp;type&apos;s&ensp;name&ensp;is&ensp;`Foo`&ensp;its&ensp;constructor&ensp;is&ensp;named&ensp;`MkFoo`.<br>  *&ensp;The&ensp;field&ensp;accessor&ensp;of&ensp;the&ensp;wrapped&ensp;Int&ensp;is&ensp;named&ensp;`value`.<br>  *&ensp;The&ensp;proof&ensp;of&ensp;validity&ensp;consists&ensp;of&ensp;a&ensp;single&ensp;zero&ensp;quantity&ensp;`So`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Refined.refinedText"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedText"><span class="name function">refinedText</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  This&ensp;creates&ensp;`Eq`,&ensp;`Ord`,&ensp;and&ensp;`Show`&ensp;implementations&ensp;as<br>  well&ensp;as&ensp;conversion&ensp;functions&ensp;for&ensp;a&ensp;refined&ensp;string&ensp;value.<br>  <br>  Conversion&ensp;functions&ensp;are&ensp;called&ensp;`refine`&ensp;and&ensp;`fromString`<br>  and&ensp;are&ensp;put&ensp;in&ensp;their&ensp;own&ensp;namespace,&ensp;named&ensp;after&ensp;the<br>  data&ensp;type&apos;s&ensp;name.<br>  <br>  ```idris&ensp;example<br>  record&ensp;Html&ensp;a&ensp;where<br>  constructor&ensp;MkHtml<br>  value&ensp;:&ensp;String<br>  0&ensp;inBounds&ensp;:&ensp;So&ensp;(isValidHtml&ensp;value)<br>  <br>  %runElab&ensp;refinedText&ensp;&quot;Html&quot;&ensp;`(Html&ensp;a)&ensp;`{{MkHtml}}&ensp;`{{value}}<br>  ```<br>  <br>  The&ensp;above&ensp;will&ensp;result&ensp;in&ensp;the&ensp;following&ensp;declarations&ensp;being&ensp;generated:<br>  <br>  ```idris&ensp;example<br>  Eq&ensp;Html&ensp;where<br>  (==)&ensp;=&ensp;(==)&ensp;`on`&ensp;value<br>  <br>  Ord&ensp;Html&ensp;where<br>  compare&ensp;=&ensp;compare&ensp;`on`&ensp;value<br>  <br>  Show&ensp;Html&ensp;where<br>  showPrec&ensp;p&ensp;=&ensp;showPrec&ensp;p&ensp;.&ensp;value<br>  <br>  namespace&ensp;Html<br>  refine&ensp;:&ensp;String&ensp;-&gt;&ensp;Maybe&ensp;Html<br>  refine&ensp;=&ensp;refineSo&ensp;MkHtml<br>  <br>  fromString&ensp;:&ensp;(v&ensp;:&ensp;String)<br>  -&gt;&ensp;{auto&ensp;0&ensp;_:&ensp;IsJust&ensp;(refine&ensp;v)}<br>  -&gt;&ensp;Html<br>  fromString&ensp;v&ensp;=&ensp;fromJust&ensp;(refine&ensp;v)<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Refined.refinedString"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedString"><span class="name function">refinedString</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  Convenience&ensp;version&ensp;of&ensp;`refinedText`&ensp;for&ensp;data&ensp;types,<br>  which&ensp;adhere&ensp;to&ensp;the&ensp;following&ensp;conventions:<br>  <br>  *&ensp;If&ensp;a&ensp;data&ensp;type&apos;s&ensp;name&ensp;is&ensp;`Foo`&ensp;its&ensp;constructor&ensp;is&ensp;named&ensp;`MkFoo`.<br>  *&ensp;The&ensp;field&ensp;accessor&ensp;of&ensp;the&ensp;wrapped&ensp;Int&ensp;is&ensp;named&ensp;`value`.<br>  *&ensp;The&ensp;proof&ensp;of&ensp;validity&ensp;consists&ensp;of&ensp;a&ensp;single&ensp;zero&ensp;quantity&ensp;`So`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Refined.refinedCharacter"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedCharacter"><span class="name function">refinedCharacter</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  This&ensp;creates&ensp;`Eq`,&ensp;`Ord`,&ensp;and&ensp;`Show`&ensp;implementations&ensp;as<br>  well&ensp;as&ensp;conversion&ensp;functions&ensp;for&ensp;a&ensp;refined&ensp;charater.<br>  <br>  Conversion&ensp;functions&ensp;are&ensp;called&ensp;`refine`&ensp;and&ensp;`fromChar`<br>  and&ensp;are&ensp;put&ensp;in&ensp;their&ensp;own&ensp;namespace,&ensp;named&ensp;after&ensp;the<br>  data&ensp;type&apos;s&ensp;name.<br>  <br>  ```idris&ensp;example<br>  record&ensp;Digit&ensp;a&ensp;where<br>  constructor&ensp;MkDigit<br>  value&ensp;:&ensp;Char<br>  0&ensp;inBounds&ensp;:&ensp;So&ensp;(isDigit&ensp;value)<br>  <br>  %runElab&ensp;refinedText&ensp;&quot;Digit&quot;&ensp;`(Digit&ensp;a)&ensp;`{{MkDigit}}&ensp;`{{value}}<br>  ```<br>  <br>  The&ensp;above&ensp;will&ensp;result&ensp;in&ensp;the&ensp;following&ensp;declarations&ensp;being&ensp;generated:<br>  <br>  ```idris&ensp;example<br>  Eq&ensp;Digit&ensp;where<br>  (==)&ensp;=&ensp;(==)&ensp;`on`&ensp;value<br>  <br>  Ord&ensp;Digit&ensp;where<br>  compare&ensp;=&ensp;compare&ensp;`on`&ensp;value<br>  <br>  Show&ensp;Digit&ensp;where<br>  showPrec&ensp;p&ensp;=&ensp;showPrec&ensp;p&ensp;.&ensp;value<br>  <br>  namespace&ensp;Digit<br>  refine&ensp;:&ensp;Char&ensp;-&gt;&ensp;Maybe&ensp;Digit<br>  refine&ensp;=&ensp;refineSo&ensp;MkDigit<br>  <br>  fromChar&ensp;:&ensp;(v&ensp;:&ensp;Char)<br>  -&gt;&ensp;{auto&ensp;0&ensp;_:&ensp;IsJust&ensp;(refine&ensp;v)}<br>  -&gt;&ensp;Digit<br>  fromChar&ensp;v&ensp;=&ensp;fromJust&ensp;(refine&ensp;v)<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Refined.refinedChar"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedChar"><span class="name function">refinedChar</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  Convenience&ensp;version&ensp;of&ensp;`refinedCharacter`&ensp;for&ensp;data&ensp;types,<br>  which&ensp;adhere&ensp;to&ensp;the&ensp;following&ensp;conventions:<br>  <br>  *&ensp;If&ensp;a&ensp;data&ensp;type&apos;s&ensp;name&ensp;is&ensp;`Foo`&ensp;its&ensp;constructor&ensp;is&ensp;named&ensp;`MkFoo`.<br>  *&ensp;The&ensp;field&ensp;accessor&ensp;of&ensp;the&ensp;wrapped&ensp;Char&ensp;is&ensp;named&ensp;`value`.<br>  *&ensp;The&ensp;proof&ensp;of&ensp;validity&ensp;consists&ensp;of&ensp;a&ensp;single&ensp;zero&ensp;quantity&ensp;`So`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd></dl></div><footer>Produced by Idris 2 version 0.5.1-7db20d38a</footer></body></html>
