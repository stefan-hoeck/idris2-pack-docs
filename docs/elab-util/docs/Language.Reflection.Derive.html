<!DOCTYPE html><html lang="en">
<head>
  <meta charset="utf-8">
  <title>Language.Reflection.Derive</title>
  <link rel="stylesheet" type="text/css" id="preferredStyle" href="../default.css">
  <script>
    /* Updates the stylesheet to use the preferred one.
       Note that we set the link to root ++ sourceLoc because the config
       is shared across the whole website, so the root may differ from
       page to page.
    */
    function setStyleSource (sourceLoc) {
      document.getElementById("preferredStyle").href = "../" + sourceLoc + ".css";
      document.getElementById("selectPreferredStyle").value = sourceLoc;
    }
    /* Initialises the preferred style sheet:
       1. if there is a stored value then use that
          otherwise select the default
       2. set both the css link href & the drop down menu selected option
    */
    function initStyleSource () {
      var preferredStyle = localStorage.getItem("stylefile");
      if (preferredStyle !== null) {
        setStyleSource(preferredStyle);
      } else {
        setStyleSource("default");
      };
    }
    function saveStyleSource (preferredStyle) {
      localStorage.stylefile = preferredStyle;
    }
    </script>
</head>
<body class="namespace">
<header>
  <strong>Idris2Doc</strong> : Language.Reflection.Derive
  <nav><a href="../index.html">Index</a>
  <select id="selectPreferredStyle">
    <option value="default">Default</option>
<option value="alternative">Alternative</option>
<option value="blackandwhite">Black & White</option>

  </select>
  </nav>
  <script>
  /* We start by initialising the style source */
  initStyleSource();
  /* This listens for changes on the drop down menu and updates the
     css used for the current page when a selection is made.
  */
  document.getElementById("selectPreferredStyle").addEventListener("change", function(){
    var selected = this.options[this.selectedIndex].value; /* the option chosen */
    setStyleSource (selected);
    saveStyleSource (selected);
  });
</script>
</header>
<div class="container"><div id="module-header"><h1>Language.Reflection.Derive</h1><span style="float:right">(<a href="Language.Reflection.Derive.src.html">source</a>)</span><pre>Utility types and functions for automatically deriving
interface instances. So far, this module does not provide
deriving functions for existing interfaces. See
Doc.Generic4 for examples, how this could be done
using the functionality provided here.
</pre></div><h2>Reexports</h2><code><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Language.Reflection.Syntax<br><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Language.Reflection.Types</code><h2>Definitions</h2><dl class="decls"><dt id="Language.Reflection.Derive.DeriveUtil"><code><span class="keyword">record</span>&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.DeriveUtil"><span class="name type">DeriveUtil</span></a>&ensp;:&ensp;<span class="name type">Type</span></code></dt><dd><pre>  Utility type for deriving interface implementations<br>  automatically. See implementations of `Eq&apos;` and `Ord&apos;`<br>  in Doc.Generic4 as examples, how this can be done.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Constructor</b>:&ensp;<dl class="decls"><dt id="Language.Reflection.Derive.MkDeriveUtil"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.MkDeriveUtil"><span class="name constructor">MkDeriveUtil</span></a>&ensp;:&ensp;<a class="type" href="Language.Reflection.Types.html#Language.Reflection.Types.ParamTypeInfo"><span class="name type">ParamTypeInfo</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.DeriveUtil"><span class="name type">DeriveUtil</span></a></code></dt></dl><br>  <b>Projections</b>:<br><dl class="decls">  <dt id="Language.Reflection.Derive.DeriveUtil.(.appliedType)"><code><span class="type resolved" title="Language.Reflection.Derive.DeriveUtil.(.appliedType)"><span class="name function">.appliedType</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.DeriveUtil"><span class="name type">DeriveUtil</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span></code></dt><dd><pre>  Fully applied data type, i.e. `var &quot;Either&quot; .$ var &quot;a&quot; .$ var &quot;b&quot;`</pre></dd>  <dt id="Language.Reflection.Derive.DeriveUtil.(.argTypesWithParams)"><code><span class="type resolved" title="Language.Reflection.Derive.DeriveUtil.(.argTypesWithParams)"><span class="name function">.argTypesWithParams</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.DeriveUtil"><span class="name type">DeriveUtil</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span></code></dt><dd><pre>  Types of constructor arguments where at least one<br>  type parameter makes an appearance. These are the<br>  `tpe` fields of `ExplicitArg` where `hasParam`<br>  is set to true and `isRecursive` is set<br>  to false. See the documentation of `ExplicitArg`<br>  when this is the case</pre></dd>  <dt id="Language.Reflection.Derive.DeriveUtil.(.paramNames)"><code><span class="type resolved" title="Language.Reflection.Derive.DeriveUtil.(.paramNames)"><span class="name function">.paramNames</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.DeriveUtil"><span class="name type">DeriveUtil</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span></code></dt><dd><pre>  The names of type parameters</pre></dd>  <dt id="Language.Reflection.Derive.DeriveUtil.(.typeInfo)"><code><span class="type resolved" title="Language.Reflection.Derive.DeriveUtil.(.typeInfo)"><span class="name function">.typeInfo</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.DeriveUtil"><span class="name type">DeriveUtil</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Types.html#Language.Reflection.Types.ParamTypeInfo"><span class="name type">ParamTypeInfo</span></a></code></dt><dd><pre>  The underlying type info containing the list and names<br>  of data constructors plus their arguments as well as<br>  the data type&apos;s name and type arguments.</pre></dd></dl></dd><dt id="Language.Reflection.Derive.DeriveUtil.(.typeInfo)"><code><span class="type resolved" title="Language.Reflection.Derive.DeriveUtil.(.typeInfo)"><span class="name function">.typeInfo</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.DeriveUtil"><span class="name type">DeriveUtil</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Types.html#Language.Reflection.Types.ParamTypeInfo"><span class="name type">ParamTypeInfo</span></a></code></dt><dd><pre>  The underlying type info containing the list and names<br>  of data constructors plus their arguments as well as<br>  the data type&apos;s name and type arguments.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.DeriveUtil.typeInfo"><code><span class="type resolved" title="Language.Reflection.Derive.DeriveUtil.typeInfo"><span class="name function">typeInfo</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.DeriveUtil"><span class="name type">DeriveUtil</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Types.html#Language.Reflection.Types.ParamTypeInfo"><span class="name type">ParamTypeInfo</span></a></code></dt><dd><pre>  The underlying type info containing the list and names<br>  of data constructors plus their arguments as well as<br>  the data type&apos;s name and type arguments.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.DeriveUtil.(.appliedType)"><code><span class="type resolved" title="Language.Reflection.Derive.DeriveUtil.(.appliedType)"><span class="name function">.appliedType</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.DeriveUtil"><span class="name type">DeriveUtil</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span></code></dt><dd><pre>  Fully applied data type, i.e. `var &quot;Either&quot; .$ var &quot;a&quot; .$ var &quot;b&quot;`</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.DeriveUtil.appliedType"><code><span class="type resolved" title="Language.Reflection.Derive.DeriveUtil.appliedType"><span class="name function">appliedType</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.DeriveUtil"><span class="name type">DeriveUtil</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span></code></dt><dd><pre>  Fully applied data type, i.e. `var &quot;Either&quot; .$ var &quot;a&quot; .$ var &quot;b&quot;`</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.DeriveUtil.(.paramNames)"><code><span class="type resolved" title="Language.Reflection.Derive.DeriveUtil.(.paramNames)"><span class="name function">.paramNames</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.DeriveUtil"><span class="name type">DeriveUtil</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span></code></dt><dd><pre>  The names of type parameters</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.DeriveUtil.paramNames"><code><span class="type resolved" title="Language.Reflection.Derive.DeriveUtil.paramNames"><span class="name function">paramNames</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.DeriveUtil"><span class="name type">DeriveUtil</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span></code></dt><dd><pre>  The names of type parameters</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.DeriveUtil.(.argTypesWithParams)"><code><span class="type resolved" title="Language.Reflection.Derive.DeriveUtil.(.argTypesWithParams)"><span class="name function">.argTypesWithParams</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.DeriveUtil"><span class="name type">DeriveUtil</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span></code></dt><dd><pre>  Types of constructor arguments where at least one<br>  type parameter makes an appearance. These are the<br>  `tpe` fields of `ExplicitArg` where `hasParam`<br>  is set to true and `isRecursive` is set<br>  to false. See the documentation of `ExplicitArg`<br>  when this is the case</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.DeriveUtil.argTypesWithParams"><code><span class="type resolved" title="Language.Reflection.Derive.DeriveUtil.argTypesWithParams"><span class="name function">argTypesWithParams</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.DeriveUtil"><span class="name type">DeriveUtil</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span></code></dt><dd><pre>  Types of constructor arguments where at least one<br>  type parameter makes an appearance. These are the<br>  `tpe` fields of `ExplicitArg` where `hasParam`<br>  is set to true and `isRecursive` is set<br>  to false. See the documentation of `ExplicitArg`<br>  when this is the case</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.genericUtil"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.genericUtil"><span class="name function">genericUtil</span></a>&ensp;:&ensp;<a class="type" href="Language.Reflection.Types.html#Language.Reflection.Types.ParamTypeInfo"><span class="name type">ParamTypeInfo</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.DeriveUtil"><span class="name type">DeriveUtil</span></a></code></dt><dd><pre>  Creates a deriving utility from information about<br>  a (possibly) parameterized type.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Derive.implName"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.implName"><span class="name function">implName</span></a>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.DeriveUtil"><span class="name type">DeriveUtil</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span></code></dt><dd><pre>  Generates the name of an interface&apos;s implementation function</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Derive.InterfaceImpl"><code><span class="keyword">record</span>&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.InterfaceImpl"><span class="name type">InterfaceImpl</span></a>&ensp;:&ensp;<span class="name type">Type</span></code></dt><dd><pre>  Syntax tree and additional info about the<br>  implementation function of an interface.<br>  <br>  With &apos;implementation function&apos;, we mean the following:<br>  When deriving an interface implementation, the elaborator<br>  creates a function returning the corresponding record value.<br>  Values of this record should provide both the full type<br>  and implementation of this function as `TTImp` values.<br>  <br>  ```idris exampel<br>  public export<br>  implEqEither : {0 a : _} -&gt; {0 b : _} -&gt; Eq a =&gt; Eq b =&gt; Eq (Either a b)<br>  implEqEither = ?impl<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Constructor</b>:&ensp;<dl class="decls"><dt id="Language.Reflection.Derive.MkInterfaceImpl"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.MkInterfaceImpl"><span class="name constructor">MkInterfaceImpl</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Visibility"><span class="name type">Visibility</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.FnOpt"><span class="name type">FnOpt</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.InterfaceImpl"><span class="name type">InterfaceImpl</span></a></code></dt></dl><br>  <b>Projections</b>:<br><dl class="decls">  <dt id="Language.Reflection.Derive.InterfaceImpl.(.impl)"><code><span class="type resolved" title="Language.Reflection.Derive.InterfaceImpl.(.impl)"><span class="name function">.impl</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.InterfaceImpl"><span class="name type">InterfaceImpl</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span></code></dt><dd><pre>  Actual implementation of the implementation function.<br>  This will be the right hand side of the sole pattern clause<br>  in the function definition.<br>  <br>  As an example, assume there is a `genEq` function used<br>  as an implementation for `(==)` for data types with<br>  some kind of `Generic` instance (see the tutorial on<br>  Generics for more information about this). An implementation<br>  for interface `Eq` could then look like this:<br>  <br>  ```idirs example<br>  impl = var (singleCon &quot;Eq&quot;) .$ `(genEq) .$ `(\a,b =&gt; not (a == b))<br>  ```</pre></dd>  <dt id="Language.Reflection.Derive.InterfaceImpl.(.interfaceName)"><code><span class="type resolved" title="Language.Reflection.Derive.InterfaceImpl.(.interfaceName)"><span class="name function">.interfaceName</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.InterfaceImpl"><span class="name type">InterfaceImpl</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">String</span></code></dt><dd><pre>  The interface&apos;s name, for instance &quot;Eq&quot; ord &quot;Ord&quot;.<br>  This is used to generate the name of the<br>  implementation function.</pre></dd>  <dt id="Language.Reflection.Derive.InterfaceImpl.(.options)"><code><span class="type resolved" title="Language.Reflection.Derive.InterfaceImpl.(.options)"><span class="name function">.options</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.InterfaceImpl"><span class="name type">InterfaceImpl</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.FnOpt"><span class="name type">FnOpt</span></span></code></dt><dd><pre>  Visibility of the implementation function.</pre></dd>  <dt id="Language.Reflection.Derive.InterfaceImpl.(.type)"><code><span class="type resolved" title="Language.Reflection.Derive.InterfaceImpl.(.type)"><span class="name function">.type</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.InterfaceImpl"><span class="name type">InterfaceImpl</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span></code></dt><dd><pre>  Full type of the implementation function, including<br>  implicit arguments (type parameters), which have to be part<br>  of the `TTImp`.<br>  <br>  See also `implementationType`, a utility function to create this<br>  kind of function types for type classes with a single parameter<br>  of type `Type`.<br>  <br>  Example:<br>  <br>  ```idirs example<br>  `({0 a: _} -&gt; {0 b : _} -&gt; Eq a =&gt; Eq b =&gt; Eq (Either a b))<br>  ```</pre></dd>  <dt id="Language.Reflection.Derive.InterfaceImpl.(.visibility)"><code><span class="type resolved" title="Language.Reflection.Derive.InterfaceImpl.(.visibility)"><span class="name function">.visibility</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.InterfaceImpl"><span class="name type">InterfaceImpl</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Visibility"><span class="name type">Visibility</span></span></code></dt><dd><pre>  Visibility of the implementation function.</pre></dd></dl></dd><dt id="Language.Reflection.Derive.InterfaceImpl.(.interfaceName)"><code><span class="type resolved" title="Language.Reflection.Derive.InterfaceImpl.(.interfaceName)"><span class="name function">.interfaceName</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.InterfaceImpl"><span class="name type">InterfaceImpl</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">String</span></code></dt><dd><pre>  The interface&apos;s name, for instance &quot;Eq&quot; ord &quot;Ord&quot;.<br>  This is used to generate the name of the<br>  implementation function.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.InterfaceImpl.interfaceName"><code><span class="type resolved" title="Language.Reflection.Derive.InterfaceImpl.interfaceName"><span class="name function">interfaceName</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.InterfaceImpl"><span class="name type">InterfaceImpl</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">String</span></code></dt><dd><pre>  The interface&apos;s name, for instance &quot;Eq&quot; ord &quot;Ord&quot;.<br>  This is used to generate the name of the<br>  implementation function.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.InterfaceImpl.(.visibility)"><code><span class="type resolved" title="Language.Reflection.Derive.InterfaceImpl.(.visibility)"><span class="name function">.visibility</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.InterfaceImpl"><span class="name type">InterfaceImpl</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Visibility"><span class="name type">Visibility</span></span></code></dt><dd><pre>  Visibility of the implementation function.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.InterfaceImpl.visibility"><code><span class="type resolved" title="Language.Reflection.Derive.InterfaceImpl.visibility"><span class="name function">visibility</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.InterfaceImpl"><span class="name type">InterfaceImpl</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Visibility"><span class="name type">Visibility</span></span></code></dt><dd><pre>  Visibility of the implementation function.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.InterfaceImpl.(.options)"><code><span class="type resolved" title="Language.Reflection.Derive.InterfaceImpl.(.options)"><span class="name function">.options</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.InterfaceImpl"><span class="name type">InterfaceImpl</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.FnOpt"><span class="name type">FnOpt</span></span></code></dt><dd><pre>  Visibility of the implementation function.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.InterfaceImpl.options"><code><span class="type resolved" title="Language.Reflection.Derive.InterfaceImpl.options"><span class="name function">options</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.InterfaceImpl"><span class="name type">InterfaceImpl</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.FnOpt"><span class="name type">FnOpt</span></span></code></dt><dd><pre>  Visibility of the implementation function.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.InterfaceImpl.(.impl)"><code><span class="type resolved" title="Language.Reflection.Derive.InterfaceImpl.(.impl)"><span class="name function">.impl</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.InterfaceImpl"><span class="name type">InterfaceImpl</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span></code></dt><dd><pre>  Actual implementation of the implementation function.<br>  This will be the right hand side of the sole pattern clause<br>  in the function definition.<br>  <br>  As an example, assume there is a `genEq` function used<br>  as an implementation for `(==)` for data types with<br>  some kind of `Generic` instance (see the tutorial on<br>  Generics for more information about this). An implementation<br>  for interface `Eq` could then look like this:<br>  <br>  ```idirs example<br>  impl = var (singleCon &quot;Eq&quot;) .$ `(genEq) .$ `(\a,b =&gt; not (a == b))<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.InterfaceImpl.impl"><code><span class="type resolved" title="Language.Reflection.Derive.InterfaceImpl.impl"><span class="name function">impl</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.InterfaceImpl"><span class="name type">InterfaceImpl</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span></code></dt><dd><pre>  Actual implementation of the implementation function.<br>  This will be the right hand side of the sole pattern clause<br>  in the function definition.<br>  <br>  As an example, assume there is a `genEq` function used<br>  as an implementation for `(==)` for data types with<br>  some kind of `Generic` instance (see the tutorial on<br>  Generics for more information about this). An implementation<br>  for interface `Eq` could then look like this:<br>  <br>  ```idirs example<br>  impl = var (singleCon &quot;Eq&quot;) .$ `(genEq) .$ `(\a,b =&gt; not (a == b))<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.InterfaceImpl.(.type)"><code><span class="type resolved" title="Language.Reflection.Derive.InterfaceImpl.(.type)"><span class="name function">.type</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.InterfaceImpl"><span class="name type">InterfaceImpl</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span></code></dt><dd><pre>  Full type of the implementation function, including<br>  implicit arguments (type parameters), which have to be part<br>  of the `TTImp`.<br>  <br>  See also `implementationType`, a utility function to create this<br>  kind of function types for type classes with a single parameter<br>  of type `Type`.<br>  <br>  Example:<br>  <br>  ```idirs example<br>  `({0 a: _} -&gt; {0 b : _} -&gt; Eq a =&gt; Eq b =&gt; Eq (Either a b))<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.InterfaceImpl.type"><code><span class="type resolved" title="Language.Reflection.Derive.InterfaceImpl.type"><span class="name function">type</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.InterfaceImpl"><span class="name type">InterfaceImpl</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span></code></dt><dd><pre>  Full type of the implementation function, including<br>  implicit arguments (type parameters), which have to be part<br>  of the `TTImp`.<br>  <br>  See also `implementationType`, a utility function to create this<br>  kind of function types for type classes with a single parameter<br>  of type `Type`.<br>  <br>  Example:<br>  <br>  ```idirs example<br>  `({0 a: _} -&gt; {0 b : _} -&gt; Eq a =&gt; Eq b =&gt; Eq (Either a b))<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.deriveDecls"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.deriveDecls"><span class="name function">deriveDecls</span></a>&ensp;:&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.DeriveUtil"><span class="name type">DeriveUtil</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.InterfaceImpl"><span class="name type">InterfaceImpl</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="type resolved" title="Language.Reflection.TTImp.Decl"><span class="name type">Decl</span></span>,&ensp;<span class="type resolved" title="Language.Reflection.TTImp.Decl"><span class="name type">Decl</span></span>))</code></dt><dd><pre>  Generates a list of pairs of declarations for the<br>  implementations of the interfaces specified.<br>  <br>  The first elements of the pairs are type declarations, while<br>  the second elements are the actual implementations.<br>  <br>  This separation of type declaration and implementation<br>  allows us to first declare all types before declaring<br>  the actual implementations. This is essential in the<br>  implementation of `deriveMutual`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Derive.derive"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.derive"><span class="name function">derive</span></a>&ensp;:&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.DeriveUtil"><span class="name type">DeriveUtil</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.InterfaceImpl"><span class="name type">InterfaceImpl</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  Given a name of a data type plus a list of interfaces, tries<br>  to implement these interfaces automatically using<br>  elaborator reflection.<br>  <br>  Again, see Doc.Generic4 for a tutorial and examples how<br>  to use this.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Derive.deriveMutual"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.deriveMutual"><span class="name function">deriveMutual</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>,&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.DeriveUtil"><span class="name type">DeriveUtil</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.InterfaceImpl"><span class="name type">InterfaceImpl</span></a>))&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  Allows the derivation of mutually dependant interface<br>  implementations by first defining type declarations before<br>  declaring implementations.<br>  <br>  Note: There is no need to call this from withi a `mutual` block.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Derive.implementationType"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.implementationType"><span class="name function">implementationType</span></a>&ensp;:&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.DeriveUtil"><span class="name type">DeriveUtil</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span></code></dt><dd><pre>  Given a `TTImp` representing an interface, generates<br>  the type of the implementation function with all type<br>  parameters applied and auto implicits specified.<br>  <br>  Example: Given the `DeriveUtil` info of `Either`, this<br>  will generate the following type for input ``(Eq)`:<br>  <br>  ```idris example<br>  {0 a : _} -&gt; {0 b : _} -&gt; Eq a =&gt; Eq b =&gt; Eq (Either a b)<br>  ```<br>  <br>  Note: This function is only to be used with single-parameter<br>  type classes, whose type parameters are of type `Type`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Derive.mkEq"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.mkEq"><span class="name function">mkEq</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Like `mkEq&apos;` but generates (/=) from the passed `eq` function.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.mkOrd"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.mkOrd"><span class="name function">mkOrd</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.EqOrd.Ordering"><span class="name type">Ordering</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Creates an `Ord` value from the passed comparison function<br>  using default implementations based on `comp` for all<br>  other function.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.mkShow"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.mkShow"><span class="name function">mkShow</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">String</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Show.Show"><span class="name type">Show</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Creates a `Show` value from the passed `show` functions.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.mkShowPrec"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.mkShowPrec"><span class="name function">mkShowPrec</span></a>&ensp;:&ensp;(<span class="type resolved" title="Prelude.Show.Prec"><span class="name type">Prec</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">String</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Show.Show"><span class="name type">Show</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Creates a `Show` value from the passed `showPrec` functions.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.mkDecEq"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.mkDecEq"><span class="name function">mkDecEq</span></a>&ensp;:&ensp;((<span class="boundvar">x1</span>&ensp;:&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">x2</span>&ensp;:&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Dec"><span class="name type">Dec</span></span>&ensp;(<span class="boundvar">x1</span>&ensp;<span class="keyword">=</span>&ensp;<span class="boundvar">x2</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Decidable.Equality.Core.DecEq"><span class="name type">DecEq</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Creates a `DecEq` value from the passed implementation function<br>  for `decEq`</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd></dl></div><footer>Produced by Idris 2 version 0.5.1-b1f2eab6d</footer></body></html>
