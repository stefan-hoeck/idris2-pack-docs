<!DOCTYPE html><html lang="en">
<head>
  <meta charset="utf-8">
  <title>Tensor</title>
  <link rel="stylesheet" type="text/css" id="preferredStyle" href="../default.css">
  <script>
    /* Updates the stylesheet to use the preferred one.
       Note that we set the link to root ++ sourceLoc because the config
       is shared across the whole website, so the root may differ from
       page to page.
    */
    function setStyleSource (sourceLoc) {
      document.getElementById("preferredStyle").href = "../" + sourceLoc + ".css";
      document.getElementById("selectPreferredStyle").value = sourceLoc;
    }
    /* Initialises the preferred style sheet:
       1. if there is a stored value then use that
          otherwise select the default
       2. set both the css link href & the drop down menu selected option
    */
    function initStyleSource () {
      var preferredStyle = localStorage.getItem("stylefile");
      if (preferredStyle !== null) {
        setStyleSource(preferredStyle);
      } else {
        setStyleSource("default");
      };
    }
    function saveStyleSource (preferredStyle) {
      localStorage.stylefile = preferredStyle;
    }
    </script>
</head>
<body class="namespace">
<header>
  <strong>Idris2Doc</strong> : Tensor
  <nav><a href="../index.html">Index</a>
  <select id="selectPreferredStyle">
    <option value="default">Default</option>
<option value="alternative">Alternative</option>
<option value="blackandwhite">Black & White</option>

  </select>
  </nav>
  <script>
  /* We start by initialising the style source */
  initStyleSource();
  /* This listens for changes on the drop down menu and updates the
     css used for the current page when a selection is made.
  */
  document.getElementById("selectPreferredStyle").addEventListener("change", function(){
    var selected = this.options[this.selectedIndex].value; /* the option chosen */
    setStyleSource (selected);
    saveStyleSource (selected);
  });
</script>
</header>
<div class="container"><div id="module-header"><h1>Tensor</h1><span style="float:right">(<a href="Tensor.src.html">source</a>)</span><pre>This module contains the `Tensor` object, an array of numbers or booleans, along with a
number of functions operating on `Tensor`s.
</pre></div><h2>Reexports</h2><code><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Data.List<br><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Data.List.Elem<br><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Primitive<br><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Types<br><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Util</code><h2>Definitions</h2><dl class="decls"><dt id="Tensor.Tensor"><code><span class="keyword">data</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;:&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<a class="type" href="Types.html#Types.Shape"><span class="name function">Shape</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  A&ensp;`Tensor`&ensp;is&ensp;a&ensp;symbolic&ensp;value,&ensp;which&ensp;may&ensp;refer&ensp;to&ensp;either&ensp;to&ensp;a&ensp;scalar&ensp;value&ensp;or&ensp;array&ensp;of&ensp;values,<br>  though&ensp;the&ensp;runtime&ensp;representation&ensp;will&ensp;likely&ensp;contain&ensp;more&ensp;than&ensp;its&ensp;value,&ensp;and&ensp;will&ensp;depend&ensp;on<br>  the&ensp;specific&ensp;backend.<br>  <br>  @shape&ensp;The&ensp;`Tensor`&ensp;shape.<br>  @dtype&ensp;The&ensp;element&ensp;type.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Constructor</b>:&ensp;<dl class="decls"><dt id="Tensor.MkTensor"><code><a class="type" href="Tensor.html#Tensor.MkTensor"><span class="name constructor">MkTensor</span></a>&ensp;:&ensp;<a class="type" href="Compiler.Expr.html#Compiler.Expr.Expr"><span class="name type">Expr</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt></dl><br>  <b>Hints</b>:<br><dl class="decls">  <dt id="$resolved405"><code><a class="type" href="Primitive.html#Primitive.Integral"><span class="name type">Integral</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Cast.Cast"><span class="name type">Cast</span></span>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">a</span>)&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>)</code></dt>  <dt id="$resolved404"><code><span class="type resolved" title="Prelude.Show.Show"><span class="name type">Show</span></span>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>)</code></dt></dl></dd><dt id="Tensor.fromLiteral"><code><a class="type" href="Tensor.html#Tensor.fromLiteral"><span class="name function">fromLiteral</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.PrimitiveRW"><span class="name type">PrimitiveRW</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Literal.html#Literal.Literal"><span class="name type">Literal</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Construct&ensp;a&ensp;`Tensor`&ensp;from&ensp;`Literal`&ensp;data.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.F64.fromDouble"><code><span class="type resolved" title="Tensor.F64.fromDouble"><span class="name function">fromDouble</span></span>&ensp;:&ensp;<span class="name type">Double</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.S32.fromInteger"><code><span class="type resolved" title="Tensor.S32.fromInteger"><span class="name function">fromInteger</span></span>&ensp;:&ensp;<span class="name type">Integer</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.S32"><span class="name type">S32</span></a></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.toLiteral"><code><a class="type" href="Tensor.html#Tensor.toLiteral"><span class="name function">toLiteral</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.PrimitiveRW"><span class="name type">PrimitiveRW</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="boundvar">ty</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Literal.html#Literal.Literal"><span class="name type">Literal</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">ty</span></code></dt><dd><pre>  Evaluate&ensp;a&ensp;`Tensor`,&ensp;returning&ensp;its&ensp;value&ensp;as&ensp;a&ensp;`Literal`.&ensp;This&ensp;function&ensp;builds&ensp;and&ensp;executes&ensp;the<br>  computation&ensp;graph.<br>  <br>  This&ensp;function&ensp;will&ensp;execute&ensp;the&ensp;graph&ensp;on&ensp;GPU&ensp;if&ensp;one&ensp;is&ensp;found,&ensp;else&ensp;it&ensp;will&ensp;use&ensp;the&ensp;host&ensp;CPU.<br>  <br>  **Note:**<br>  *&ensp;Each&ensp;call&ensp;to&ensp;`toLiteral`&ensp;will&ensp;rebuild&ensp;and&ensp;execute&ensp;the&ensp;graph.&ensp;Similarly,&ensp;multiple&ensp;calls&ensp;to<br>  `toLiteral`&ensp;on&ensp;different&ensp;`Tensor`s&ensp;in&ensp;a&ensp;computation&ensp;will&ensp;be&ensp;treated&ensp;entirely&ensp;independently.<br>  `toLiteral`&ensp;does&ensp;not&ensp;store&ensp;intermediate&ensp;values.&ensp;This&ensp;is&ensp;a&ensp;known&ensp;limitation,&ensp;and&ensp;may&ensp;change&ensp;in<br>  the&ensp;future.<br>  *&ensp;`toLiteral`&ensp;performs&ensp;logging&ensp;as&ensp;a&ensp;side&ensp;effect.&ensp;You&ensp;can&ensp;disable&ensp;this&ensp;by&ensp;adjusting&ensp;the<br>  TensorFlow&ensp;logging&ensp;level&ensp;e.g.&ensp;with&ensp;`export&ensp;TF_CPP_MIN_LOG_LEVEL=3`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.reshape"><code><a class="type" href="Tensor.html#Tensor.reshape"><span class="name function">reshape</span></a>&ensp;:&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Interfaces.product"><span class="name function">product</span></span>&ensp;<span class="boundvar">from</span>&ensp;<span class="keyword">=</span>&ensp;<span class="type resolved" title="Prelude.Interfaces.product"><span class="name function">product</span></span>&ensp;<span class="boundvar">to</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">from</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">to</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Reshape&ensp;a&ensp;`Tensor`.&ensp;For&ensp;example,&ensp;`reshape&ensp;{to=[2,&ensp;1]}&ensp;(fromLiteral&ensp;[3,&ensp;4])`&ensp;is<br>  `fromLiteral&ensp;[[3],&ensp;[4]]`.&ensp;The&ensp;output&ensp;can&ensp;have&ensp;a&ensp;different&ensp;rank&ensp;to&ensp;the&ensp;input.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.expand"><code><a class="type" href="Tensor.html#Tensor.expand"><span class="name function">expand</span></a>&ensp;:&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">axis</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">inBounds</span>&ensp;:&ensp;<span class="type resolved" title="Data.Nat.LTE"><span class="name type">LTE</span></span>&ensp;<span class="boundvar">axis</span>&ensp;(<span class="type resolved" title="Prelude.Types.List.length"><span class="name function">length</span></span>&ensp;<span class="boundvar">shape</span>)}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;(<span class="type resolved" title="Data.List.insertAt"><span class="name function">insertAt</span></span>&ensp;<span class="boundvar">axis</span>&ensp;<span class="name constructor">1</span>&ensp;<span class="boundvar">shape</span>)&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Add&ensp;a&ensp;dimension&ensp;of&ensp;length&ensp;one&ensp;at&ensp;the&ensp;specified&ensp;`axis`.&ensp;The&ensp;new&ensp;dimension&ensp;will&ensp;be&ensp;at&ensp;the<br>  specified&ensp;`axis`&ensp;in&ensp;the&ensp;new&ensp;`Tensor`&ensp;(as&ensp;opposed&ensp;to&ensp;the&ensp;original&ensp;`Tensor`).&ensp;For&ensp;example,<br>  `expand&ensp;1&ensp;$&ensp;fromLiteral&ensp;[[1,&ensp;2],&ensp;[3,&ensp;4],&ensp;[5,&ensp;6]]`&ensp;is<br>  `fromLiteral&ensp;[[[1,&ensp;2]],&ensp;[[3,&ensp;4]],&ensp;[[5,&ensp;6]]]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.Squeezable.Squeezable"><code><span class="keyword">data</span>&ensp;<span class="type resolved" title="Tensor.Squeezable.Squeezable"><span class="name type">Squeezable</span></span>&ensp;:&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<a class="type" href="Types.html#Types.Shape"><span class="name function">Shape</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<a class="type" href="Types.html#Types.Shape"><span class="name function">Shape</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  A&ensp;`Squeezable&ensp;from&ensp;to`&ensp;constitutes&ensp;proof&ensp;that&ensp;the&ensp;shape&ensp;`from`&ensp;can&ensp;be&ensp;squeezed&ensp;to&ensp;the<br>  shape&ensp;`to`.&ensp;Squeezing&ensp;is&ensp;the&ensp;process&ensp;of&ensp;removing&ensp;any&ensp;number&ensp;of&ensp;dimensions&ensp;of&ensp;length&ensp;one.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Constructors</b>:<br><dl class="decls">  <dt id="Tensor.Squeezable.Same"><code><span class="type resolved" title="Tensor.Squeezable.Same"><span class="name constructor">Same</span></span>&ensp;:&ensp;<span class="type resolved" title="Tensor.Squeezable.Squeezable"><span class="name type">Squeezable</span></span>&ensp;<span class="boundvar">x</span>&ensp;<span class="boundvar">x</span></code></dt><dd><pre>  Proof&ensp;that&ensp;a&ensp;shape&ensp;can&ensp;be&ensp;squeezed&ensp;to&ensp;itself.&ensp;For&ensp;example:<br>  <br>  []&ensp;to&ensp;[]<br>  [3,&ensp;4]&ensp;to&ensp;[3,&ensp;4]</pre></dd>  <dt id="Tensor.Squeezable.Match"><code><span class="type resolved" title="Tensor.Squeezable.Match"><span class="name constructor">Match</span></span>&ensp;:&ensp;<span class="type resolved" title="Tensor.Squeezable.Squeezable"><span class="name type">Squeezable</span></span>&ensp;<span class="boundvar">from</span>&ensp;<span class="boundvar">to</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Tensor.Squeezable.Squeezable"><span class="name type">Squeezable</span></span>&ensp;(<span class="boundvar">x</span>&ensp;<span class="type resolved" title="Prelude.Basics.::"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">from</span>)&ensp;(<span class="boundvar">x</span>&ensp;<span class="type resolved" title="Prelude.Basics.::"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">to</span>)</code></dt><dd><pre>  Proof&ensp;that&ensp;any&ensp;dimensions&ensp;(including&ensp;those&ensp;of&ensp;length&ensp;1)&ensp;can&ensp;be&ensp;preserved&ensp;in&ensp;the&ensp;process&ensp;of<br>  squeezing.&ensp;For&ensp;example:<br>  <br>  ...</pre></dd>  <dt id="Tensor.Squeezable.Nest"><code><span class="type resolved" title="Tensor.Squeezable.Nest"><span class="name constructor">Nest</span></span>&ensp;:&ensp;<span class="type resolved" title="Tensor.Squeezable.Squeezable"><span class="name type">Squeezable</span></span>&ensp;<span class="boundvar">from</span>&ensp;<span class="boundvar">to</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Tensor.Squeezable.Squeezable"><span class="name type">Squeezable</span></span>&ensp;(<span class="name constructor">1</span>&ensp;<span class="type resolved" title="Prelude.Basics.::"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">from</span>)&ensp;<span class="boundvar">to</span></code></dt><dd><pre>  Proof&ensp;that&ensp;any&ensp;dimensions&ensp;of&ensp;length&ensp;one&ensp;can&ensp;be&ensp;squeezed&ensp;out.&ensp;For&ensp;example:<br>  <br>  [1,&ensp;3,&ensp;1,&ensp;1,&ensp;4]&ensp;to&ensp;[3,&ensp;4]</pre></dd></dl></dd><dt id="Tensor.squeeze"><code><a class="type" href="Tensor.html#Tensor.squeeze"><span class="name function">squeeze</span></a>&ensp;:&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Tensor.Squeezable.Squeezable"><span class="name type">Squeezable</span></span>&ensp;<span class="boundvar">from</span>&ensp;<span class="boundvar">to</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">from</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">to</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Remove&ensp;dimensions&ensp;of&ensp;length&ensp;one&ensp;from&ensp;a&ensp;`Tensor`&ensp;such&ensp;that&ensp;it&ensp;has&ensp;the&ensp;desired&ensp;shape.&ensp;For&ensp;example:<br>  <br>  ```idris<br>  x&ensp;:&ensp;Tensor&ensp;[2,&ensp;1,&ensp;3,&ensp;1]&ensp;S32<br>  x&ensp;=&ensp;fromLiteral&ensp;[[[[4],&ensp;[5],&ensp;[6]]],&ensp;[[[7],&ensp;[8],&ensp;[9]]]]<br>  <br>  y&ensp;:&ensp;Tensor&ensp;[2,&ensp;1,&ensp;3]&ensp;S32<br>  y&ensp;=&ensp;squeeze&ensp;x<br>  ```<br>  <br>  is<br>  <br>  ```idris<br>  y&ensp;:&ensp;Tensor&ensp;[2,&ensp;1,&ensp;3]&ensp;S32<br>  y&ensp;=&ensp;fromLiteral&ensp;[[[4,&ensp;5,&ensp;6]],&ensp;[[7,&ensp;8,&ensp;9]]]<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.SliceOrIndex"><code><span class="keyword">data</span>&ensp;<a class="type" href="Tensor.html#Tensor.SliceOrIndex"><span class="name type">SliceOrIndex</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  A&ensp;`SliceOrIndex&ensp;d`&ensp;is&ensp;a&ensp;valid&ensp;slice&ensp;or&ensp;index&ensp;into&ensp;a&ensp;dimension&ensp;of&ensp;size&ensp;`d`.&ensp;See&ensp;`slice`&ensp;for<br>  details.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Constructors</b>:<br><dl class="decls">  <dt id="Tensor.Slice"><code><a class="type" href="Tensor.html#Tensor.Slice"><span class="name constructor">Slice</span></a>&ensp;:&ensp;(<span class="boundvar">from</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">to</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="boundvar">from</span>&ensp;<span class="type resolved" title="Prelude.Num.+"><span class="name function">+</span></span>&ensp;<span class="boundvar">size</span>&ensp;<span class="keyword">=</span>&ensp;<span class="boundvar">to</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Data.Nat.LTE"><span class="name type">LTE</span></span>&ensp;<span class="boundvar">to</span>&ensp;<span class="boundvar">d</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.SliceOrIndex"><span class="name type">SliceOrIndex</span></a>&ensp;<span class="boundvar">d</span></code></dt>  <dt id="Tensor.Index"><code><a class="type" href="Tensor.html#Tensor.Index"><span class="name constructor">Index</span></a>&ensp;:&ensp;(<span class="boundvar">idx</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Data.Nat.LT"><span class="name function">LT</span></span>&ensp;<span class="boundvar">idx</span>&ensp;<span class="boundvar">d</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.SliceOrIndex"><span class="name type">SliceOrIndex</span></a>&ensp;<span class="boundvar">d</span></code></dt>  <dt id="Tensor.DynamicSlice"><code><a class="type" href="Tensor.html#Tensor.DynamicSlice"><span class="name constructor">DynamicSlice</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.U64"><span class="name type">U64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">size</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Data.Nat.LTE"><span class="name type">LTE</span></span>&ensp;<span class="boundvar">size</span>&ensp;<span class="boundvar">d</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.SliceOrIndex"><span class="name type">SliceOrIndex</span></a>&ensp;<span class="boundvar">d</span></code></dt>  <dt id="Tensor.DynamicIndex"><code><a class="type" href="Tensor.html#Tensor.DynamicIndex"><span class="name constructor">DynamicIndex</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.U64"><span class="name type">U64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.SliceOrIndex"><span class="name type">SliceOrIndex</span></a>&ensp;<span class="boundvar">d</span></code></dt></dl></dd><dt id="Tensor.at"><code><a class="type" href="Tensor.html#Tensor.at"><span class="name function">at</span></a>&ensp;:&ensp;(<span class="boundvar">idx</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Data.Nat.LT"><span class="name function">LT</span></span>&ensp;<span class="boundvar">idx</span>&ensp;<span class="boundvar">d</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.SliceOrIndex"><span class="name type">SliceOrIndex</span></a>&ensp;<span class="boundvar">d</span></code></dt><dd><pre>  Index&ensp;at&ensp;`idx`.&ensp;See&ensp;`slice`&ensp;for&ensp;details.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Tensor.Dynamic.at"><code><span class="type resolved" title="Tensor.Dynamic.at"><span class="name function">at</span></span>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.U64"><span class="name type">U64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.SliceOrIndex"><span class="name type">SliceOrIndex</span></a>&ensp;<span class="boundvar">d</span></code></dt><dd><pre>  Index&ensp;at&ensp;the&ensp;specified&ensp;index.&ensp;See&ensp;`slice`&ensp;for&ensp;details.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Tensor.(.to)"><code><a class="type" href="Tensor.html#Tensor.(.to)"><span class="name function">.to</span></a>&ensp;:&ensp;(<span class="boundvar">from</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">to</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="boundvar">from</span>&ensp;<span class="type resolved" title="Prelude.Num.+"><span class="name function">+</span></span>&ensp;<span class="boundvar">size</span>&ensp;<span class="keyword">=</span>&ensp;<span class="boundvar">to</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Data.Nat.LTE"><span class="name type">LTE</span></span>&ensp;<span class="boundvar">to</span>&ensp;<span class="boundvar">d</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.SliceOrIndex"><span class="name type">SliceOrIndex</span></a>&ensp;<span class="boundvar">d</span></code></dt><dd><pre>  Slice&ensp;from&ensp;`from`&ensp;(inclusive)&ensp;to&ensp;`to`&ensp;(exclusive).&ensp;See&ensp;`slice`&ensp;for&ensp;details.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Tensor.(.size)"><code><a class="type" href="Tensor.html#Tensor.(.size)"><span class="name function">.size</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.U64"><span class="name type">U64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">size</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Data.Nat.LTE"><span class="name type">LTE</span></span>&ensp;<span class="boundvar">size</span>&ensp;<span class="boundvar">d</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.SliceOrIndex"><span class="name type">SliceOrIndex</span></a>&ensp;<span class="boundvar">d</span></code></dt><dd><pre>  Slice&ensp;`size`&ensp;elements&ensp;starting&ensp;at&ensp;the&ensp;specified&ensp;scalar&ensp;`U64`&ensp;index.&ensp;See&ensp;`slice`&ensp;for&ensp;details.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Tensor.all"><code><a class="type" href="Tensor.html#Tensor.all"><span class="name function">all</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.SliceOrIndex"><span class="name type">SliceOrIndex</span></a>&ensp;<span class="boundvar">d</span></code></dt><dd><pre>  Slice&ensp;across&ensp;all&ensp;indices&ensp;along&ensp;an&ensp;axis.&ensp;See&ensp;`slice`&ensp;for&ensp;details.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Tensor.MultiSlice"><code><span class="keyword">data</span>&ensp;<a class="type" href="Tensor.html#Tensor.MultiSlice"><span class="name type">MultiSlice</span></a>&ensp;:&ensp;<a class="type" href="Types.html#Types.Shape"><span class="name function">Shape</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  A&ensp;`MultiSlice&ensp;shape`&ensp;is&ensp;a&ensp;valid&ensp;multi-dimensionsal&ensp;slice&ensp;into&ensp;a&ensp;tensor&ensp;with&ensp;shape&ensp;`shape`.<br>  See&ensp;`slice`&ensp;for&ensp;details.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Constructors</b>:<br><dl class="decls">  <dt id="Tensor.Nil"><code><a class="type" href="Tensor.html#Tensor.Nil"><span class="name constructor">Nil</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.MultiSlice"><span class="name type">MultiSlice</span></a>&ensp;<span class="boundvar">ds</span></code></dt>  <dt id="Tensor.::"><code><a class="type" href="Tensor.html#Tensor.::"><span class="name constructor">(::)</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.SliceOrIndex"><span class="name type">SliceOrIndex</span></a>&ensp;<span class="boundvar">d</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.MultiSlice"><span class="name type">MultiSlice</span></a>&ensp;<span class="boundvar">ds</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.MultiSlice"><span class="name type">MultiSlice</span></a>&ensp;(<span class="boundvar">d</span>&ensp;<span class="type resolved" title="Prelude.Basics.::"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">ds</span>)</code></dt></dl></dd><dt id="Tensor.MultiSlice.slice"><code><span class="type resolved" title="Tensor.MultiSlice.slice"><span class="name function">slice</span></span>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.MultiSlice"><span class="name type">MultiSlice</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Types.html#Types.Shape"><span class="name function">Shape</span></a></code></dt><dd><pre>  The&ensp;shape&ensp;of&ensp;a&ensp;tensor&ensp;produced&ensp;by&ensp;slicing&ensp;with&ensp;the&ensp;specified&ensp;multi-dimensional&ensp;slice.&ensp;See<br>  `Tensor.slice`&ensp;for&ensp;details.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Tensor.slice"><code><a class="type" href="Tensor.html#Tensor.slice"><span class="name function">slice</span></a>&ensp;:&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">at</span>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.MultiSlice"><span class="name type">MultiSlice</span></a>&ensp;<span class="boundvar">shape</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;(<span class="type resolved" title="Tensor.MultiSlice.slice"><span class="name function">slice</span></span>&ensp;<span class="boundvar">at</span>)&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Slice&ensp;or&ensp;index&ensp;`Tensor`&ensp;axes.&ensp;Each&ensp;axis&ensp;can&ensp;be&ensp;sliced&ensp;or&ensp;indexed,&ensp;and&ensp;this&ensp;can&ensp;be&ensp;done&ensp;with<br>  either&ensp;static&ensp;(`Nat`)&ensp;or&ensp;dynamic&ensp;(scalar&ensp;`U64`)&ensp;indices.<br>  <br>  **Static&ensp;indices**<br>  <br>  Static&ensp;indices&ensp;are&ensp;`Nat`s.&ensp;For&ensp;example,&ensp;for<br>  ```<br>  x&ensp;:&ensp;Tensor&ensp;[5,&ensp;6]&ensp;S32<br>  x&ensp;=&ensp;fromLiteral&ensp;[<br>  [&ensp;0,&ensp;1,&ensp;2,&ensp;3,&ensp;4,&ensp;5],<br>  [&ensp;6,&ensp;7,&ensp;8,&ensp;9,&ensp;10,&ensp;11],<br>  [12,&ensp;13,&ensp;14,&ensp;15,&ensp;16,&ensp;17],<br>  [18,&ensp;19,&ensp;20,&ensp;21,&ensp;22,&ensp;23],<br>  [24,&ensp;25,&ensp;26,&ensp;27,&ensp;28,&ensp;29]<br>  ]<br>  ```<br>  we&ensp;can&ensp;index&ensp;as&ensp;`slice&ensp;[at&ensp;1]&ensp;x`&ensp;to&ensp;get<br>  ```<br>  x&ensp;:&ensp;Tensor&ensp;[6]&ensp;S32<br>  x&ensp;=&ensp;fromLiteral&ensp;[6,&ensp;7,&ensp;8,&ensp;9,&ensp;10,&ensp;11]<br>  ```<br>  or&ensp;we&ensp;can&ensp;slice&ensp;as&ensp;`slice&ensp;[2.to&ensp;4]&ensp;x`&ensp;to&ensp;get<br>  ```<br>  x&ensp;:&ensp;Tensor&ensp;[2,&ensp;6]&ensp;S32<br>  x&ensp;=&ensp;fromLiteral&ensp;[<br>  [12,&ensp;13,&ensp;14,&ensp;15,&ensp;16,&ensp;17],<br>  [18,&ensp;19,&ensp;20,&ensp;21,&ensp;22,&ensp;23]<br>  ]<br>  ```<br>  Note&ensp;that&ensp;in&ensp;`2.to&ensp;4`,&ensp;the&ensp;2&ensp;is&ensp;inclusive,&ensp;and&ensp;the&ensp;4&ensp;exclusive,&ensp;so&ensp;we&ensp;return&ensp;indices&ensp;2&ensp;and&ensp;3.<br>  <br>  **Dynamic&ensp;indices**<br>  <br>  Dynamic&ensp;indices&ensp;are&ensp;scalar&ensp;`U64`&ensp;values,&ensp;and&ensp;the&ensp;API&ensp;works&ensp;slightly&ensp;differently&ensp;because&ensp;we<br>  can&apos;t&ensp;know&ensp;the&ensp;value&ensp;of&ensp;dynamic&ensp;indices&ensp;until&ensp;the&ensp;graph&ensp;is&ensp;executed.&ensp;For&ensp;indexing,&ensp;with&ensp;scalar<br>  `U64`&ensp;index&ensp;`i`&ensp;in&ensp;`slice&ensp;[at&ensp;i]&ensp;x`,&ensp;`i`&ensp;is&ensp;clamped&ensp;to&ensp;be&ensp;a&ensp;valid&ensp;index&ensp;into&ensp;that&ensp;dimension.<br>  For&ensp;example,&ensp;for&ensp;`i&ensp;=&ensp;fromLiteral&ensp;1`,&ensp;`slice&ensp;[at&ensp;i]&ensp;x`&ensp;is<br>  ```<br>  x&ensp;:&ensp;Tensor&ensp;[6]&ensp;S32<br>  x&ensp;=&ensp;fromLiteral&ensp;[6,&ensp;7,&ensp;8,&ensp;9,&ensp;10,&ensp;11]<br>  ```<br>  as&ensp;in&ensp;the&ensp;static&ensp;case.&ensp;However,&ensp;for&ensp;`i&ensp;=&ensp;fromLiteral&ensp;10`,&ensp;`slice&ensp;[at&ensp;i]&ensp;x`&ensp;returns&ensp;the&ensp;last&ensp;row<br>  ```<br>  x&ensp;:&ensp;Tensor&ensp;[6]&ensp;S32<br>  x&ensp;=&ensp;fromLiteral&ensp;[24,&ensp;25,&ensp;26,&ensp;27,&ensp;28,&ensp;29]<br>  ```<br>  We&ensp;can&ensp;also&ensp;slice&ensp;by&ensp;specifying&ensp;a&ensp;scalar&ensp;`U64`&ensp;start&ensp;index,&ensp;and&ensp;a&ensp;static&ensp;size,&ensp;as<br>  `slice&ensp;[i.size&ensp;2]&ensp;x`&ensp;with&ensp;`i&ensp;=&ensp;fromLiteral&ensp;2`&ensp;to&ensp;get<br>  ```<br>  x&ensp;:&ensp;Tensor&ensp;[2,&ensp;6]&ensp;S32<br>  x&ensp;=&ensp;fromLiteral&ensp;[<br>  [12,&ensp;13,&ensp;14,&ensp;15,&ensp;16,&ensp;17],<br>  [18,&ensp;19,&ensp;20,&ensp;21,&ensp;22,&ensp;23]<br>  ]<br>  ```<br>  For&ensp;a&ensp;given&ensp;slice&ensp;`size`,&ensp;the&ensp;dynamic&ensp;start&ensp;index&ensp;is&ensp;clamped&ensp;such&ensp;that&ensp;we&ensp;always&ensp;get&ensp;`size`<br>  elements&ensp;along&ensp;that&ensp;axis.&ensp;For&ensp;example,&ensp;`slice&ensp;[i.size&ensp;2]&ensp;x`&ensp;with&ensp;`i&ensp;=&ensp;fromLiteral&ensp;4`&ensp;is<br>  ```<br>  x&ensp;:&ensp;Tensor&ensp;[2,&ensp;6]&ensp;S32<br>  x&ensp;=&ensp;fromLiteral&ensp;[<br>  [18,&ensp;19,&ensp;20,&ensp;21,&ensp;22,&ensp;23],<br>  [24,&ensp;25,&ensp;26,&ensp;27,&ensp;28,&ensp;29]<br>  ]<br>  ```<br>  which&ensp;starts&ensp;at&ensp;index&ensp;3&ensp;rather&ensp;than&ensp;index&ensp;4.<br>  <br>  **Mixed&ensp;static,&ensp;dynamic,&ensp;slicing&ensp;and&ensp;indexing**<br>  <br>  Each&ensp;axis&ensp;can&ensp;only&ensp;be&ensp;sliced&ensp;or&ensp;indexed,&ensp;and&ensp;must&ensp;use&ensp;only&ensp;static&ensp;or&ensp;dynamic&ensp;indices.&ensp;However,<br>  across&ensp;axes,&ensp;we&ensp;can&ensp;mix&ensp;these&ensp;four&ensp;arbitrarily.&ensp;For&ensp;example,&ensp;with&ensp;`slice&ensp;[2.to&ensp;4,&ensp;at&ensp;1]&ensp;x`&ensp;to<br>  get<br>  ```<br>  x&ensp;:&ensp;Tensor&ensp;[2]&ensp;S32<br>  x&ensp;=&ensp;fromLiteral&ensp;[13,&ensp;19]<br>  ```<br>  or&ensp;with&ensp;`i&ensp;=&ensp;fromLiteral&ensp;2`&ensp;in&ensp;`slice&ensp;[at&ensp;1,&ensp;i.size&ensp;2]&ensp;x`&ensp;to&ensp;get<br>  ```<br>  x&ensp;:&ensp;Tensor&ensp;[2]&ensp;S32<br>  x&ensp;=&ensp;fromLiteral&ensp;[7,&ensp;8]<br>  ```<br>  <br>  Slices&ensp;and&ensp;indices&ensp;apply&ensp;to&ensp;the&ensp;leading&ensp;axes&ensp;of&ensp;the&ensp;tensor.&ensp;For&ensp;trailing&ensp;axes&ensp;omitted&ensp;from&ensp;the<br>  multi-dimensional&ensp;slice,&ensp;the&ensp;whole&ensp;of&ensp;the&ensp;axis&ensp;is&ensp;returned.&ensp;If&ensp;we&ensp;want&ensp;to&ensp;slice&ensp;or&ensp;index&ensp;over<br>  later&ensp;axes&ensp;and&ensp;retain&ensp;all&ensp;indices&ensp;in&ensp;a&ensp;leading&ensp;axis,&ensp;we&ensp;can&ensp;use&ensp;the&ensp;convenience&ensp;function&ensp;`all`,<br>  as&ensp;`slice&ensp;[all,&ensp;at&ensp;3]&ensp;x`&ensp;to&ensp;get<br>  ```<br>  x&ensp;:&ensp;Tensor&ensp;[5]&ensp;S32<br>  x&ensp;=&ensp;fromLiteral&ensp;[[3],&ensp;[9],&ensp;[15],&ensp;[21],&ensp;[27]]<br>  ```<br>  This&ensp;is&ensp;exactly&ensp;the&ensp;same&ensp;as&ensp;the&ensp;more&ensp;manual&ensp;`slice&ensp;[0.to&ensp;5,&ensp;at&ensp;3]&ensp;x`&ensp;and<br>  `slice&ensp;[(fromLiteral&ensp;0).size&ensp;5,&ensp;at&ensp;3]&ensp;x`.<br>  <br>  @at&ensp;The&ensp;multi-dimensional&ensp;slices&ensp;and&ensp;indices&ensp;at&ensp;which&ensp;to&ensp;slice&ensp;the&ensp;tensor.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.concat"><code><a class="type" href="Tensor.html#Tensor.concat"><span class="name function">concat</span></a>&ensp;:&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">axis</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">s</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">s&apos;</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">inBounds</span>&ensp;:&ensp;(<span class="type resolved" title="Data.List.InBounds"><span class="name type">InBounds</span></span>&ensp;<span class="boundvar">axis</span>&ensp;<span class="boundvar">s</span>,&ensp;<span class="type resolved" title="Data.List.InBounds"><span class="name type">InBounds</span></span>&ensp;<span class="boundvar">axis</span>&ensp;<span class="boundvar">s&apos;</span>)}&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Data.List.deleteAt"><span class="name function">deleteAt</span></span>&ensp;<span class="boundvar">axis</span>&ensp;<span class="boundvar">s</span>&ensp;<span class="keyword">=</span>&ensp;<span class="type resolved" title="Data.List.deleteAt"><span class="name function">deleteAt</span></span>&ensp;<span class="boundvar">axis</span>&ensp;<span class="boundvar">s&apos;</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;(<span class="type resolved" title="Data.List.replaceAt"><span class="name function">replaceAt</span></span>&ensp;<span class="boundvar">axis</span>&ensp;(<span class="type resolved" title="Data.List.index"><span class="name function">index</span></span>&ensp;<span class="boundvar">axis</span>&ensp;<span class="boundvar">s</span>&ensp;<span class="type resolved" title="Prelude.Num.+"><span class="name function">+</span></span>&ensp;<span class="type resolved" title="Data.List.index"><span class="name function">index</span></span>&ensp;<span class="boundvar">axis</span>&ensp;<span class="boundvar">s&apos;</span>)&ensp;<span class="boundvar">s</span>)&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Concatenate&ensp;two&ensp;`Tensor`s&ensp;along&ensp;the&ensp;specfied&ensp;`axis`.&ensp;For&ensp;example,<br>  `concat&ensp;0&ensp;(fromLiteral&ensp;[[1,&ensp;2],&ensp;[3,&ensp;4]])&ensp;(fromLiteral&ensp;[[5,&ensp;6]])`&ensp;and<br>  `concat&ensp;1&ensp;(fromLiteral&ensp;[[3],&ensp;[6]])&ensp;fromLiteral&ensp;([[4,&ensp;5],&ensp;[7,&ensp;8]])`&ensp;are&ensp;both<br>  `fromLiteral&ensp;[[1,&ensp;2],&ensp;[3,&ensp;4],&ensp;[5,&ensp;6]]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.diag"><code><a class="type" href="Tensor.html#Tensor.diag"><span class="name function">diag</span></a>&ensp;:&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">n</span>,&ensp;<span class="boundvar">n</span>]&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">n</span>]&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  The&ensp;diagonal&ensp;of&ensp;a&ensp;matrix&ensp;as&ensp;a&ensp;vector.&ensp;For&ensp;example,&ensp;for<br>  ```<br>  x&ensp;:&ensp;Tensor&ensp;[3,&ensp;3]&ensp;S32<br>  x&ensp;=&ensp;fromLiteral&ensp;[[0,&ensp;1,&ensp;2],<br>  [3,&ensp;4,&ensp;5],<br>  [6,&ensp;7,&ensp;8]]<br>  ```<br>  `diag&ensp;x`&ensp;is&ensp;`fromLiteral&ensp;[0,&ensp;4,&ensp;8]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.Triangle"><code><span class="keyword">data</span>&ensp;<a class="type" href="Tensor.html#Tensor.Triangle"><span class="name type">Triangle</span></a>&ensp;:&ensp;<span class="name type">Type</span></code></dt><dd><pre>  Represents&ensp;the&ensp;upper-&ensp;or&ensp;lower-trinagular&ensp;component&ensp;of&ensp;a&ensp;matrix.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Constructors</b>:<br><dl class="decls">  <dt id="Tensor.Upper"><code><a class="type" href="Tensor.html#Tensor.Upper"><span class="name constructor">Upper</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Triangle"><span class="name type">Triangle</span></a></code></dt>  <dt id="Tensor.Lower"><code><a class="type" href="Tensor.html#Tensor.Lower"><span class="name constructor">Lower</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Triangle"><span class="name type">Triangle</span></a></code></dt></dl></dd><dt id="Tensor.triangle"><code><a class="type" href="Tensor.html#Tensor.triangle"><span class="name function">triangle</span></a>&ensp;:&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Triangle"><span class="name type">Triangle</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">n</span>,&ensp;<span class="boundvar">n</span>]&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">n</span>,&ensp;<span class="boundvar">n</span>]&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Get&ensp;the&ensp;upper-&ensp;or&ensp;lower-triangular&ensp;component&ensp;of&ensp;a&ensp;matrix.&ensp;For&ensp;example,&ensp;for<br>  ```<br>  x&ensp;:&ensp;Tensor&ensp;[3,&ensp;3]&ensp;S32<br>  x&ensp;=&ensp;fromLiteral&ensp;[[1,&ensp;2,&ensp;3],<br>  [4,&ensp;5,&ensp;6],<br>  [7,&ensp;8,&ensp;9]]<br>  ```<br>  `triangle&ensp;Lower&ensp;x`&ensp;is<br>  ```<br>  x&ensp;:&ensp;Tensor&ensp;[3,&ensp;3]&ensp;S32<br>  x&ensp;=&ensp;fromLiteral&ensp;[[1,&ensp;0,&ensp;0],<br>  [4,&ensp;5,&ensp;0],<br>  [7,&ensp;8,&ensp;9]]<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.(.T)"><code><a class="type" href="Tensor.html#Tensor.(.T)"><span class="name function">.T</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">m</span>,&ensp;<span class="boundvar">n</span>]&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">n</span>,&ensp;<span class="boundvar">m</span>]&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Tranpose&ensp;a&ensp;matrix.&ensp;For&ensp;example,&ensp;`(fromLiteral&ensp;[[1,&ensp;2],&ensp;[3,&ensp;4]]).T`&ensp;is<br>  `fromLiteral&ensp;[[1,&ensp;3],&ensp;[2,&ensp;4]]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.transpose"><code><a class="type" href="Tensor.html#Tensor.transpose"><span class="name function">transpose</span></a>&ensp;:&ensp;(<span class="boundvar">ordering</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.List.length"><span class="name function">length</span></span>&ensp;<span class="boundvar">ordering</span>&ensp;<span class="keyword">=</span>&ensp;<span class="type resolved" title="Prelude.Types.List.length"><span class="name function">length</span></span>&ensp;<span class="boundvar">shape</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Util.List.Sorted"><span class="name type">Sorted</span></span>&ensp;<a class="type" href="Util.html#Util.Neq"><span class="name function">Neq</span></a>&ensp;<span class="boundvar">ordering</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">inBounds</span>&ensp;:&ensp;<span class="type resolved" title="Data.List.Quantifiers.All.All"><span class="name type">All</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.flip"><span class="name function">flip</span></span>&ensp;<span class="type resolved" title="Data.List.InBounds"><span class="name type">InBounds</span></span>&ensp;<span class="boundvar">shape</span>)&ensp;<span class="boundvar">ordering</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;(<span class="type resolved" title="Util.List.All.map"><span class="name function">map</span></span>&ensp;(<a class="type" href="Util.html#Util.dflip"><span class="name function">dflip</span></a>&ensp;<span class="type resolved" title="Data.List.index"><span class="name function">index</span></span>&ensp;<span class="boundvar">shape</span>)&ensp;<span class="boundvar">ordering</span>)&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Transpose&ensp;axes&ensp;of&ensp;a&ensp;tensor.&ensp;This&ensp;is&ensp;a&ensp;more&ensp;general&ensp;version&ensp;of&ensp;`(.T)`,&ensp;in&ensp;which&ensp;you&ensp;can&ensp;transpose<br>  any&ensp;number&ensp;of&ensp;axes&ensp;in&ensp;a&ensp;tensor&ensp;of&ensp;arbitrary&ensp;rank.&ensp;The&ensp;i&apos;th&ensp;axis&ensp;in&ensp;the&ensp;resulting&ensp;tensor<br>  corresponds&ensp;to&ensp;the&ensp;`index&ensp;i&ensp;ordering`&apos;th&ensp;axis&ensp;in&ensp;the&ensp;input&ensp;tensor.&ensp;For&ensp;example,&ensp;for<br>  ```<br>  x&ensp;:&ensp;Tensor&ensp;[2,&ensp;3,&ensp;4]&ensp;S32<br>  x&ensp;=&ensp;fromLiteral&ensp;[[[&ensp;0,&ensp;1,&ensp;2,&ensp;3],<br>  [&ensp;4,&ensp;5,&ensp;6,&ensp;7],<br>  [&ensp;8,&ensp;9,&ensp;10,&ensp;11]],<br>  [[12,&ensp;13,&ensp;14,&ensp;15],<br>  [16,&ensp;17,&ensp;18,&ensp;19],<br>  [20,&ensp;21,&ensp;22,&ensp;23]]]<br>  ```<br>  `transpose&ensp;[0,&ensp;2,&ensp;1]`&ensp;is<br>  ```<br>  x&ensp;:&ensp;Tensor&ensp;[2,&ensp;4,&ensp;3]&ensp;S32<br>  x&ensp;=&ensp;fromLiteral&ensp;[[[&ensp;0,&ensp;4,&ensp;8],<br>  [&ensp;1,&ensp;5,&ensp;9],<br>  [&ensp;2,&ensp;6,&ensp;10],<br>  [&ensp;3,&ensp;7,&ensp;11]],<br>  [[12,&ensp;16,&ensp;20],<br>  [13,&ensp;17,&ensp;21],<br>  [14,&ensp;18,&ensp;22],<br>  [15,&ensp;19,&ensp;23]]]<br>  ```<br>  `transpose&ensp;[2,&ensp;0,&ensp;1]`&ensp;is<br>  ```<br>  x&ensp;:&ensp;Tensor&ensp;[4,&ensp;2,&ensp;3]&ensp;S32<br>  x&ensp;=&ensp;fromLiteral&ensp;[[[&ensp;0,&ensp;4,&ensp;8],<br>  [12,&ensp;16,&ensp;20]],<br>  [[&ensp;1,&ensp;5,&ensp;9],<br>  [13,&ensp;17,&ensp;21]],<br>  [[&ensp;2,&ensp;6,&ensp;10],<br>  [14,&ensp;18,&ensp;22]],<br>  [[&ensp;3,&ensp;7,&ensp;11],<br>  [15,&ensp;19,&ensp;23]]]<br>  ```<br>  <br>  In&ensp;order&ensp;to&ensp;see&ensp;what&ensp;effect&ensp;transposing&ensp;a&ensp;tensor&ensp;has,&ensp;it&ensp;can&ensp;help&ensp;to&ensp;bear&ensp;in&ensp;mind&ensp;the&ensp;following:<br>  *&ensp;if&ensp;an&ensp;element&ensp;can&ensp;be&ensp;found&ensp;with&ensp;`slice&ensp;[at&ensp;3,&ensp;at&ensp;4,&ensp;at&ensp;5]&ensp;x`&ensp;in&ensp;the&ensp;original&ensp;tensor,<br>  that&ensp;same&ensp;element&ensp;can&ensp;instead&ensp;be&ensp;found&ensp;with&ensp;`slice&ensp;[at&ensp;5,&ensp;at&ensp;3,&ensp;at&ensp;4]`&ensp;given&ensp;a<br>  `transpose&ensp;[2,&ensp;0,&ensp;1]`.&ensp;That&ensp;is,&ensp;transposing&ensp;axes&ensp;re-orders&ensp;indices&ensp;when&ensp;indexing.<br>  *&ensp;with&ensp;`transpose&ensp;[2,&ensp;0,&ensp;1]`,&ensp;traversing&ensp;the&ensp;first&ensp;axis&ensp;in&ensp;the&ensp;result&ensp;is&ensp;equivalent&ensp;to<br>  traversing&ensp;the&ensp;last&ensp;axis&ensp;in&ensp;the&ensp;input.&ensp;Similarly,&ensp;traversing&ensp;the&ensp;last&ensp;axis&ensp;in&ensp;the&ensp;result&ensp;is<br>  equivalent&ensp;to&ensp;traversing&ensp;the&ensp;second&ensp;axis&ensp;in&ensp;the&ensp;input.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.identity"><code><a class="type" href="Tensor.html#Tensor.identity"><span class="name function">identity</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Num"><span class="name type">Num</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">n</span>,&ensp;<span class="boundvar">n</span>]&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  The&ensp;identity&ensp;tensor,&ensp;with&ensp;inferred&ensp;shape&ensp;and&ensp;element&ensp;type.&ensp;For&ensp;example,<br>  ```<br>  x&ensp;:&ensp;Tensor&ensp;[2,&ensp;2]&ensp;S32<br>  x&ensp;=&ensp;identity<br>  ```<br>  is<br>  ```<br>  x&ensp;:&ensp;Tensor&ensp;[2,&ensp;2]&ensp;S32<br>  x&ensp;=&ensp;[[1,&ensp;0],<br>  [0,&ensp;1]]<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.DimBroadcastable"><code><span class="keyword">data</span>&ensp;<a class="type" href="Tensor.html#Tensor.DimBroadcastable"><span class="name type">DimBroadcastable</span></a>&ensp;:&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  A&ensp;`DimBroadcastable&ensp;from&ensp;to`&ensp;proves&ensp;that&ensp;a&ensp;dimension&ensp;of&ensp;size&ensp;`from`&ensp;can&ensp;be&ensp;broadcast&ensp;to&ensp;a<br>  dimension&ensp;of&ensp;size&ensp;`to`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Constructors</b>:<br><dl class="decls">  <dt id="Tensor.Same"><code><a class="type" href="Tensor.html#Tensor.Same"><span class="name constructor">Same</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.DimBroadcastable"><span class="name type">DimBroadcastable</span></a>&ensp;<span class="boundvar">x</span>&ensp;<span class="boundvar">x</span></code></dt><dd><pre>  Proof&ensp;that&ensp;any&ensp;dimension&ensp;can&ensp;be&ensp;broadcast&ensp;to&ensp;itself.&ensp;For&ensp;example&ensp;in&ensp;shapes&ensp;`[2,&ensp;3]`&ensp;to<br>  `[2,&ensp;3]`.</pre></dd>  <dt id="Tensor.Stack"><code><a class="type" href="Tensor.html#Tensor.Stack"><span class="name constructor">Stack</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.DimBroadcastable"><span class="name type">DimBroadcastable</span></a>&ensp;<span class="name constructor">1</span>&ensp;<span class="boundvar">{_:4684}</span></code></dt><dd><pre>  Proof&ensp;that&ensp;a&ensp;dimension&ensp;of&ensp;length&ensp;one&ensp;can&ensp;be&ensp;broadcast&ensp;to&ensp;any&ensp;size.&ensp;For&ensp;example&ensp;in&ensp;shapes<br>  `[2,&ensp;1]`&ensp;to&ensp;`[2,&ensp;3]`</pre></dd>  <dt id="Tensor.Zero"><code><a class="type" href="Tensor.html#Tensor.Zero"><span class="name constructor">Zero</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.DimBroadcastable"><span class="name type">DimBroadcastable</span></a>&ensp;<span class="boundvar">{_:4690}</span>&ensp;<span class="name constructor">0</span></code></dt><dd><pre>  Proof&ensp;that&ensp;any&ensp;dimension&ensp;can&ensp;be&ensp;broadcast&ensp;to&ensp;zero.&ensp;For&ensp;example&ensp;in&ensp;shapes&ensp;`[2,&ensp;3]`&ensp;to&ensp;`[2,&ensp;0]`.</pre></dd></dl></dd><dt id="Tensor.Broadcastable.Broadcastable"><code><span class="keyword">data</span>&ensp;<span class="type resolved" title="Tensor.Broadcastable.Broadcastable"><span class="name type">Broadcastable</span></span>&ensp;:&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<a class="type" href="Types.html#Types.Shape"><span class="name function">Shape</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<a class="type" href="Types.html#Types.Shape"><span class="name function">Shape</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  A&ensp;`Broadcastable&ensp;from&ensp;to`&ensp;constitutes&ensp;proof&ensp;that&ensp;the&ensp;shape&ensp;`from`&ensp;can&ensp;be&ensp;broadcast&ensp;to&ensp;the<br>  shape&ensp;`to`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Constructors</b>:<br><dl class="decls">  <dt id="Tensor.Broadcastable.Same"><code><span class="type resolved" title="Tensor.Broadcastable.Same"><span class="name constructor">Same</span></span>&ensp;:&ensp;<span class="type resolved" title="Tensor.Broadcastable.Broadcastable"><span class="name type">Broadcastable</span></span>&ensp;<span class="boundvar">x</span>&ensp;<span class="boundvar">x</span></code></dt><dd><pre>  Proof&ensp;that&ensp;a&ensp;shape&ensp;can&ensp;be&ensp;broadcast&ensp;to&ensp;itself.&ensp;For&ensp;example:<br>  <br>  []&ensp;to&ensp;[]<br>  [3,&ensp;4]&ensp;to&ensp;[3,&ensp;4]<br>  <br>  Implementation&ensp;note:&ensp;we&ensp;could&ensp;have&ensp;used&ensp;`Broadcast&ensp;[]&ensp;[]`,&ensp;which&ensp;would&ensp;have&ensp;resulted&ensp;in&ensp;more<br>  atomic&ensp;constructors&ensp;for&ensp;`Broadcastable`,&ensp;but&ensp;the&ensp;author&ensp;guesses&ensp;that&ensp;this&ensp;implementation&ensp;helps<br>  the&ensp;type&ensp;checker&ensp;avoid&ensp;applications&ensp;of&ensp;`Match`.</pre></dd>  <dt id="Tensor.Broadcastable.Match"><code><span class="type resolved" title="Tensor.Broadcastable.Match"><span class="name constructor">Match</span></span>&ensp;:&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.List.length"><span class="name function">length</span></span>&ensp;<span class="boundvar">from</span>&ensp;<span class="keyword">=</span>&ensp;<span class="type resolved" title="Prelude.Types.List.length"><span class="name function">length</span></span>&ensp;<span class="boundvar">to</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.DimBroadcastable"><span class="name type">DimBroadcastable</span></a>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">t</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Tensor.Broadcastable.Broadcastable"><span class="name type">Broadcastable</span></span>&ensp;<span class="boundvar">from</span>&ensp;<span class="boundvar">to</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Tensor.Broadcastable.Broadcastable"><span class="name type">Broadcastable</span></span>&ensp;(<span class="boundvar">f</span>&ensp;<span class="type resolved" title="Prelude.Basics.::"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">from</span>)&ensp;(<span class="boundvar">t</span>&ensp;<span class="type resolved" title="Prelude.Basics.::"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">to</span>)</code></dt><dd><pre>  Proof&ensp;that&ensp;a&ensp;dimension&ensp;of&ensp;size&ensp;`f`&ensp;can&ensp;be&ensp;broadcast&ensp;to&ensp;size&ensp;`t`&ensp;if&ensp;these&ensp;dimensions<br>  are&ensp;`DimBroadcastable&ensp;f&ensp;t`.&ensp;For&ensp;example:<br>  <br>  [2,&ensp;3]&ensp;to&ensp;[2,&ensp;3]<br>  [2,&ensp;1]&ensp;to&ensp;[2,&ensp;3]<br>  [2,&ensp;1]&ensp;to&ensp;[2,&ensp;0]</pre></dd>  <dt id="Tensor.Broadcastable.Nest"><code><span class="type resolved" title="Tensor.Broadcastable.Nest"><span class="name constructor">Nest</span></span>&ensp;:&ensp;<span class="type resolved" title="Tensor.Broadcastable.Broadcastable"><span class="name type">Broadcastable</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">t</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Tensor.Broadcastable.Broadcastable"><span class="name type">Broadcastable</span></span>&ensp;<span class="boundvar">f</span>&ensp;(<span class="boundvar">{_:4741}</span>&ensp;<span class="type resolved" title="Prelude.Basics.::"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">t</span>)</code></dt><dd><pre>  Proof&ensp;that&ensp;broadcasting&ensp;can&ensp;add&ensp;outer&ensp;dimensions&ensp;i.e.&ensp;nesting.&ensp;For&ensp;example:<br>  <br>  [3]&ensp;to&ensp;[1,&ensp;3]<br>  [3]&ensp;to&ensp;[5,&ensp;3]</pre></dd></dl><br>  <b>Hint</b>:&ensp;<dl class="decls"><dt id="$resolved590"><code>(<span class="boundvar">to</span>&ensp;:&ensp;<a class="type" href="Types.html#Types.Shape"><span class="name function">Shape</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Tensor.Broadcastable.Broadcastable"><span class="name type">Broadcastable</span></span>&ensp;[]&ensp;<span class="boundvar">to</span></code></dt></dl></dd><dt id="Tensor.broadcast"><code><a class="type" href="Tensor.html#Tensor.broadcast"><span class="name function">broadcast</span></a>&ensp;:&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Tensor.Broadcastable.Broadcastable"><span class="name type">Broadcastable</span></span>&ensp;<span class="boundvar">from</span>&ensp;<span class="boundvar">to</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">from</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">to</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Broadcast&ensp;a&ensp;`Tensor`&ensp;to&ensp;a&ensp;new&ensp;compatible&ensp;shape.&ensp;For&ensp;example,<br>  <br>  ```idris<br>  x&ensp;:&ensp;Tensor&ensp;[2,&ensp;3]&ensp;S32<br>  x&ensp;=&ensp;broadcast&ensp;(fromLiteral&ensp;[4,&ensp;5,&ensp;6])<br>  ```<br>  <br>  is<br>  <br>  ```idris<br>  x&ensp;:&ensp;Tensor&ensp;[2,&ensp;3]&ensp;S32<br>  x&ensp;=&ensp;fromLiteral&ensp;[[4,&ensp;5,&ensp;6],&ensp;[4,&ensp;5,&ensp;6]]<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.scalarToAnyOk"><code><a class="type" href="Tensor.html#Tensor.scalarToAnyOk"><span class="name function">scalarToAnyOk</span></a>&ensp;:&ensp;(<span class="boundvar">to</span>&ensp;:&ensp;<a class="type" href="Types.html#Types.Shape"><span class="name function">Shape</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Tensor.Broadcastable.Broadcastable"><span class="name type">Broadcastable</span></span>&ensp;[]&ensp;<span class="boundvar">to</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.fill"><code><a class="type" href="Tensor.html#Tensor.fill"><span class="name function">fill</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.PrimitiveRW"><span class="name type">PrimitiveRW</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="boundvar">ty</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">ty</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  A&ensp;`Tensor`&ensp;where&ensp;every&ensp;element&ensp;has&ensp;the&ensp;specified&ensp;value.&ensp;For&ensp;example,<br>  <br>  ```idris<br>  fives&ensp;:&ensp;Tensor&ensp;[2,&ensp;3]&ensp;S32<br>  fives&ensp;=&ensp;fill&ensp;5<br>  ```<br>  is<br>  ```idris<br>  fives&ensp;:&ensp;Tensor&ensp;[2,&ensp;3]&ensp;S32<br>  fives&ensp;=&ensp;fromLiteral&ensp;[[5,&ensp;5,&ensp;5],&ensp;[5,&ensp;5,&ensp;5]]<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.map"><code><a class="type" href="Tensor.html#Tensor.map"><span class="name function">map</span></a>&ensp;:&ensp;(<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">a</span>,&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">=&gt;</span>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">b</span></code></dt><dd><pre>  Lift&ensp;a&ensp;unary&ensp;function&ensp;on&ensp;scalars&ensp;to&ensp;an&ensp;element-wise&ensp;function&ensp;on&ensp;`Tensor`s&ensp;of&ensp;arbitrary&ensp;shape.<br>  For&ensp;example,<br>  ```idris<br>  recip&ensp;:&ensp;Tensor&ensp;[]&ensp;F64&ensp;-&gt;&ensp;Tensor&ensp;[]&ensp;F64<br>  recip&ensp;=&ensp;(1.0&ensp;/)<br>  ```<br>  can&ensp;be&ensp;lifted&ensp;to&ensp;an&ensp;element-wise&ensp;reciprocal&ensp;function&ensp;as&ensp;`map&ensp;recip&ensp;(fromLiteral&ensp;[-2,&ensp;0.4])`,<br>  which&ensp;is&ensp;`fromLiteral&ensp;[-0.5,&ensp;2.5]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.map2"><code><a class="type" href="Tensor.html#Tensor.map2"><span class="name function">map2</span></a>&ensp;:&ensp;(<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">a</span>,&ensp;(<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">b</span>,&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">c</span>))&ensp;<span class="keyword">=&gt;</span>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<span class="boundvar">c</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">c</span></code></dt><dd><pre>  Lift&ensp;a&ensp;binary&ensp;function&ensp;on&ensp;scalars&ensp;to&ensp;an&ensp;element-wise&ensp;function&ensp;on&ensp;`Tensor`s&ensp;of&ensp;arbitrary&ensp;shape.<br>  For&ensp;example,<br>  ```idris<br>  addRecip&ensp;:&ensp;Tensor&ensp;[]&ensp;F64&ensp;-&gt;&ensp;Tensor&ensp;[]&ensp;F64&ensp;-&gt;&ensp;Tensor&ensp;[]&ensp;F64<br>  addRecip&ensp;x&ensp;y&ensp;=&ensp;x&ensp;+&ensp;1.0&ensp;/&ensp;y<br>  ```<br>  can&ensp;be&ensp;lifted&ensp;to&ensp;an&ensp;element-wise&ensp;function&ensp;as<br>  `map2&ensp;addRecip&ensp;(fromLiteral&ensp;[3.0,&ensp;-3.0])&ensp;(fromLiteral&ensp;[-2.0,&ensp;0.4])`,&ensp;which&ensp;is<br>  `fromLiteral&ensp;[2.5,&ensp;-0.5]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.reduce"><code><a class="type" href="Tensor.html#Tensor.reduce"><span class="name function">reduce</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Interfaces.Monoid"><span class="name type">Monoid</span></span>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<span class="boundvar">dtype</span>)&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">axes</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">axesUnique</span>&ensp;:&ensp;<span class="type resolved" title="Util.List.Sorted"><span class="name type">Sorted</span></span>&ensp;<span class="type resolved" title="Data.Nat.LT"><span class="name function">LT</span></span>&ensp;<span class="boundvar">axes</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">axesInBounds</span>&ensp;:&ensp;<span class="type resolved" title="Data.List.Quantifiers.All.All"><span class="name type">All</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.flip"><span class="name function">flip</span></span>&ensp;<span class="type resolved" title="Data.List.InBounds"><span class="name type">InBounds</span></span>&ensp;<span class="boundvar">shape</span>)&ensp;<span class="boundvar">axes</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;(<span class="type resolved" title="Util.List.deleteAt"><span class="name function">deleteAt</span></span>&ensp;<span class="boundvar">axes</span>&ensp;<span class="boundvar">shape</span>)&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Reduce&ensp;elements&ensp;along&ensp;one&ensp;`axis`&ensp;of&ensp;a&ensp;`Tensor`&ensp;according&ensp;to&ensp;a&ensp;specified&ensp;`reducer`&ensp;`Monoid`.<br>  For&ensp;example,&ensp;if&ensp;`x&ensp;=&ensp;fromLiteral&ensp;[[0,&ensp;1,&ensp;2],&ensp;[3,&ensp;4,&ensp;5]]`,&ensp;then&ensp;reduce&ensp;@{Sum}&ensp;0&ensp;x`&ensp;is<br>  `fromLiteral&ensp;[3,&ensp;5,&ensp;7]`&ensp;and&ensp;`reduce&ensp;@{Sum}&ensp;1&ensp;x`&ensp;to&ensp;`fromLiteral&ensp;[3,&ensp;12]`.<br>  <br>  @reducer&ensp;How&ensp;to&ensp;reduce&ensp;elements&ensp;along&ensp;the&ensp;given&ensp;`axis`.<br>  @axis&ensp;The&ensp;axis&ensp;along&ensp;which&ensp;to&ensp;reduce&ensp;elements.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.sort"><code><a class="type" href="Tensor.html#Tensor.sort"><span class="name function">sort</span></a>&ensp;:&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">dimension</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Data.List.InBounds"><span class="name type">InBounds</span></span>&ensp;<span class="boundvar">dimension</span>&ensp;<span class="boundvar">shape</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Sort&ensp;the&ensp;elements&ensp;of&ensp;a&ensp;`Tensor`&ensp;along&ensp;a&ensp;specified&ensp;`dimension`&ensp;according&ensp;to&ensp;a&ensp;scalar-wise<br>  ordering.&ensp;For&ensp;sorting&ensp;function&ensp;`f`,&ensp;elements&ensp;are&ensp;sorted&ensp;such&ensp;that&ensp;for&ensp;consecutive&ensp;sorted<br>  elements&ensp;`a`&ensp;and&ensp;`b`,&ensp;either&ensp;`f&ensp;a&ensp;b`&ensp;is&ensp;true,&ensp;or&ensp;`f&ensp;a&ensp;b`&ensp;*and*&ensp;`f&ensp;b&ensp;a`&ensp;are&ensp;false.<br>  <br>  **Note:**&ensp;Sorting&ensp;is&ensp;not&ensp;stable,&ensp;meaning&ensp;elements&ensp;that&ensp;compare&ensp;equal&ensp;according&ensp;the&ensp;ordering&ensp;may<br>  be&ensp;sorted&ensp;in&ensp;a&ensp;different&ensp;order&ensp;to&ensp;the&ensp;order&ensp;they&ensp;appear&ensp;in&ensp;the&ensp;input.<br>  <br>  For&ensp;example,&ensp;for&ensp;`x&ensp;=&ensp;fromLiteral&ensp;[[1,&ensp;6,&ensp;4],&ensp;[3,&ensp;2,&ensp;5]]`,&ensp;`sort&ensp;(&lt;)&ensp;0&ensp;x`&ensp;is<br>  `fromLiteral&ensp;[[1,&ensp;2,&ensp;4],&ensp;[3,&ensp;6,&ensp;5]]`&ensp;and&ensp;`sort&ensp;(&lt;)&ensp;1&ensp;x`&ensp;is&ensp;`fromLiteral&ensp;[[1,&ensp;4,&ensp;6],&ensp;[2,&ensp;3,&ensp;5]]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.reverse"><code><a class="type" href="Tensor.html#Tensor.reverse"><span class="name function">reverse</span></a>&ensp;:&ensp;(<span class="boundvar">axes</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Util.List.Sorted"><span class="name type">Sorted</span></span>&ensp;<span class="type resolved" title="Data.Nat.LT"><span class="name function">LT</span></span>&ensp;<span class="boundvar">axes</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Data.List.Quantifiers.All.All"><span class="name type">All</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.flip"><span class="name function">flip</span></span>&ensp;<span class="type resolved" title="Data.List.InBounds"><span class="name type">InBounds</span></span>&ensp;<span class="boundvar">shape</span>)&ensp;<span class="boundvar">axes</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Reverse&ensp;elements&ensp;along&ensp;the&ensp;specified&ensp;axes.&ensp;For&ensp;example,&ensp;for<br>  ```<br>  x&ensp;:&ensp;Tensor&ensp;[2,&ensp;3]&ensp;S32<br>  x&ensp;=&ensp;fromLiteral&ensp;[[-2,&ensp;-1,&ensp;0],<br>  [&ensp;1,&ensp;2,&ensp;3]]<br>  ```<br>  `reverse&ensp;[0]&ensp;x`&ensp;is<br>  ```<br>  x&ensp;:&ensp;Tensor&ensp;[2,&ensp;3]&ensp;S32<br>  x&ensp;=&ensp;fromLiteral&ensp;[[&ensp;1,&ensp;2,&ensp;3],<br>  [-2,&ensp;-1,&ensp;0]]<br>  ```<br>  `reverse&ensp;[1]&ensp;x`&ensp;is<br>  ```<br>  x&ensp;:&ensp;Tensor&ensp;[2,&ensp;3]&ensp;S32<br>  x&ensp;=&ensp;fromLiteral&ensp;[[&ensp;0,&ensp;-1,&ensp;-2],<br>  [&ensp;3,&ensp;2,&ensp;1]]<br>  ```<br>  and&ensp;`reverse&ensp;[0,&ensp;1]&ensp;x`&ensp;is<br>  ```<br>  x&ensp;:&ensp;Tensor&ensp;[2,&ensp;3]&ensp;S32<br>  x&ensp;=&ensp;fromLiteral&ensp;[[&ensp;3,&ensp;2,&ensp;1],<br>  [&ensp;0,&ensp;-1,&ensp;-2]]<br>  ```<br>  <br>  **Note:**&ensp;This&ensp;function&ensp;requires&ensp;`axes`&ensp;is&ensp;ordered&ensp;simply&ensp;so&ensp;that&ensp;elements&ensp;are&ensp;unique.<br>  The&ensp;ordering&ensp;itself&ensp;is&ensp;irrelevant&ensp;to&ensp;the&ensp;implementation,&ensp;but&ensp;ensures&ensp;uniqueness&ensp;without&ensp;using<br>  proofs&ensp;of&ensp;contradiction&ensp;that&ensp;can&ensp;be&ensp;difficult&ensp;for&ensp;Idris&ensp;to&ensp;construct.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.=="><code><a class="type" href="Tensor.html#Tensor.=="><span class="name function">(==)</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Eq"><span class="name type">Eq</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a></code></dt><dd><pre>  `fromLiteral&ensp;[True,&ensp;False]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infix&ensp;operator,&ensp;level&ensp;6</dd><dt id="Tensor./="><code><a class="type" href="Tensor.html#Tensor./="><span class="name function">(/=)</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Eq"><span class="name type">Eq</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a></code></dt><dd><pre>  Element-wise&ensp;inequality.&ensp;For&ensp;example,&ensp;`fromLiteral&ensp;[1,&ensp;2]&ensp;/=&ensp;fromLiteral&ensp;[1,&ensp;3]`&ensp;is<br>  `fromLiteral&ensp;[False,&ensp;True]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infix&ensp;operator,&ensp;level&ensp;6</dd><dt id="Tensor.&lt;"><code><a class="type" href="Tensor.html#Tensor.&lt;"><span class="name function">(<)</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Ord"><span class="name type">Ord</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a></code></dt><dd><pre>  Element-wise&ensp;less&ensp;than.&ensp;For&ensp;example,&ensp;`fromLiteral&ensp;[1,&ensp;2,&ensp;3]&ensp;<&ensp;fromLiteral&ensp;[2,&ensp;2,&ensp;2]`&ensp;is<br>  `fromLiteral&ensp;[True,&ensp;False,&ensp;False]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infix&ensp;operator,&ensp;level&ensp;6</dd><dt id="Tensor.&gt;"><code><a class="type" href="Tensor.html#Tensor.&gt;"><span class="name function">(>)</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Ord"><span class="name type">Ord</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a></code></dt><dd><pre>  Element-wise&ensp;greater&ensp;than.&ensp;For&ensp;example,&ensp;`fromLiteral&ensp;[1,&ensp;2,&ensp;3]&ensp;>&ensp;fromLiteral&ensp;[2,&ensp;2,&ensp;2]`&ensp;is<br>  `fromLiteral&ensp;[False,&ensp;False,&ensp;True]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infix&ensp;operator,&ensp;level&ensp;6</dd><dt id="Tensor.&lt;="><code><a class="type" href="Tensor.html#Tensor.&lt;="><span class="name function">(&lt;=)</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Ord"><span class="name type">Ord</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a></code></dt><dd><pre>  Element-wise&ensp;less&ensp;than&ensp;or&ensp;equal.&ensp;For&ensp;example,&ensp;`fromLiteral&ensp;[1,&ensp;2,&ensp;3]&ensp;&lt;=&ensp;fromLiteral&ensp;[2,&ensp;2,&ensp;2]`<br>  is&ensp;`fromLiteral&ensp;[True,&ensp;True,&ensp;False]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infix&ensp;operator,&ensp;level&ensp;6</dd><dt id="Tensor.&gt;="><code><a class="type" href="Tensor.html#Tensor.&gt;="><span class="name function">(&gt;=)</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Ord"><span class="name type">Ord</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a></code></dt><dd><pre>  Element-wise&ensp;greater&ensp;than&ensp;or&ensp;equal.&ensp;For&ensp;example,<br>  `fromLiteral&ensp;[1,&ensp;2,&ensp;3]&ensp;&gt;=&ensp;fromLiteral&ensp;[2,&ensp;2,&ensp;2]`&ensp;is&ensp;`fromLiteral&ensp;[False,&ensp;True,&ensp;True]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infix&ensp;operator,&ensp;level&ensp;6</dd><dt id="Tensor.&amp;&amp;"><code><a class="type" href="Tensor.html#Tensor.&amp;&amp;"><span class="name function">(&amp;&amp;)</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a></code></dt><dd><pre>  Element-wise&ensp;boolean&ensp;and.&ensp;For&ensp;example,<br>  `fromLiteral&ensp;[True,&ensp;True,&ensp;False,&ensp;False]&ensp;&amp;&amp;&ensp;fromLiteral&ensp;[True,&ensp;False,&ensp;True,&ensp;False]`&ensp;is<br>  `fromLiteral&ensp;[True,&ensp;False,&ensp;False,&ensp;False]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infixr&ensp;operator,&ensp;level&ensp;5</dd><dt id="Tensor.||"><code><a class="type" href="Tensor.html#Tensor.||"><span class="name function">(||)</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a></code></dt><dd><pre>  Element-wise&ensp;boolean&ensp;or.&ensp;For&ensp;example,<br>  `fromLiteral&ensp;[True,&ensp;True,&ensp;False,&ensp;False]&ensp;||&ensp;fromLiteral&ensp;[True,&ensp;False,&ensp;True,&ensp;False]`&ensp;is<br>  `fromLiteral&ensp;[True,&ensp;True,&ensp;True,&ensp;False]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infixr&ensp;operator,&ensp;level&ensp;4</dd><dt id="Tensor.not"><code><a class="type" href="Tensor.html#Tensor.not"><span class="name function">not</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a></code></dt><dd><pre>  Element-wise&ensp;boolean&ensp;negation.&ensp;For&ensp;example,&ensp;`not&ensp;(fromLiteral&ensp;[True,&ensp;False])`&ensp;is<br>  `fromLiteral&ensp;[False,&ensp;True]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.select"><code><a class="type" href="Tensor.html#Tensor.select"><span class="name function">select</span></a>&ensp;:&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Choose&ensp;elements&ensp;from&ensp;two&ensp;`Tensor`s&ensp;based&ensp;on&ensp;a&ensp;`Tensor`&ensp;of&ensp;predicates.&ensp;For&ensp;each&ensp;element&ensp;in&ensp;the<br>  predicates,&ensp;the&ensp;output&ensp;will&ensp;use&ensp;the&ensp;corresponding&ensp;element&ensp;from&ensp;`onTrue`&ensp;if&ensp;the&ensp;element&ensp;is<br>  truthy,&ensp;else&ensp;the&ensp;element&ensp;from&ensp;`onFalse`.&ensp;For&ensp;example,&ensp;for<br>  ```<br>  preds&ensp;:&ensp;Tensor&ensp;[3]&ensp;PRED<br>  preds&ensp;=&ensp;fromLiteral&ensp;[False,&ensp;True,&ensp;False]<br>  <br>  onTrue&ensp;:&ensp;Tensor&ensp;[3]&ensp;S32<br>  onTrue&ensp;=&ensp;fromLiteral&ensp;[1,&ensp;2,&ensp;3]<br>  <br>  onFalse&ensp;:&ensp;Tensor&ensp;[3]&ensp;S32<br>  onFalse&ensp;=&ensp;fromLiteral&ensp;[4,&ensp;5,&ensp;6]<br>  ```<br>  `select&ensp;preds&ensp;onTrue&ensp;onFalse`&ensp;is&ensp;`fromLiteral&ensp;[4,&ensp;2,&ensp;6]`.<br>  <br>  @onTrue&ensp;The&ensp;elements&ensp;to&ensp;choose&ensp;where&ensp;the&ensp;predicate&ensp;elements&ensp;are&ensp;truthy.<br>  @onFalse&ensp;The&ensp;elements&ensp;to&ensp;choose&ensp;where&ensp;the&ensp;predicate&ensp;elements&ensp;are&ensp;falsy.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.cond"><code><a class="type" href="Tensor.html#Tensor.cond"><span class="name function">cond</span></a>&ensp;:&ensp;(<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">tt</span>,&ensp;(<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">ft</span>,&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">dtype</span>))&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">ts</span>&ensp;<span class="boundvar">tt</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">ts</span>&ensp;<span class="boundvar">tt</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">fs</span>&ensp;<span class="boundvar">ft</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">fs</span>&ensp;<span class="boundvar">ft</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Use&ensp;a&ensp;scalar&ensp;predicate&ensp;to&ensp;choose&ensp;which&ensp;of&ensp;two&ensp;functions&ensp;to&ensp;evaluate.&ensp;If&ensp;the&ensp;predicte&ensp;is&ensp;truthy,<br>  evaluate&ensp;`onTrue`&ensp;on&ensp;the&ensp;corresponding&ensp;specified&ensp;argument,&ensp;otherwise&ensp;evaluate&ensp;`onFalse`&ensp;on&ensp;the<br>  corresponding&ensp;specified&ensp;argument.&ensp;The&ensp;result&ensp;of&ensp;the&ensp;evaluated&ensp;function&ensp;is&ensp;returned.&ensp;For&ensp;example,<br>  for<br>  ```<br>  x&ensp;:&ensp;Tensor&ensp;[2]&ensp;S32<br>  x&ensp;=&ensp;fromLiteral&ensp;[2,&ensp;-1]<br>  <br>  y&ensp;:&ensp;Tensor&ensp;[2,&ensp;2]&ensp;S32<br>  y&ensp;=&ensp;fromLiteral&ensp;[[5,&ensp;6],<br>  [7,&ensp;8]]<br>  ```<br>  `cond&ensp;(fromLiteral&ensp;True)&ensp;(fromLiteral&ensp;2&ensp;*)&ensp;x&ensp;diag&ensp;y`&ensp;is&ensp;`fromLiteral&ensp;[4,&ensp;-2]`&ensp;and<br>  `cond&ensp;(fromLiteral&ensp;False)&ensp;(fromLiteral&ensp;2&ensp;*)&ensp;x&ensp;diag&ensp;y`&ensp;to&ensp;`fromLiteral&ensp;[5,&ensp;8]`.<br>  <br>  While&ensp;both&ensp;functions&ensp;will&ensp;be&ensp;called&ensp;for&ensp;the&ensp;purposes&ensp;of&ensp;defining&ensp;the&ensp;computation,&ensp;only&ensp;one&ensp;will<br>  be&ensp;evaluated&ensp;with&ensp;its&ensp;specified&ensp;argument.&ensp;That&ensp;is,&ensp;this&ensp;function&ensp;short-circuits.<br>  <br>  @onTrue&ensp;The&ensp;function&ensp;to&ensp;execute&ensp;if&ensp;the&ensp;predicate&ensp;is&ensp;truthy.<br>  @onFalse&ensp;The&ensp;function&ensp;to&ensp;execute&ensp;if&ensp;the&ensp;predicate&ensp;is&ensp;falsy.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.Vector.@@"><code><span class="type resolved" title="Tensor.Vector.@@"><span class="name function">(@@)</span></span>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Num"><span class="name type">Num</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">m</span>]&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">m</span>]&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Vector&ensp;dot&ensp;product&ensp;with&ensp;a&ensp;tensor&ensp;of&ensp;any&ensp;rank.&ensp;The&ensp;vector&ensp;dot&ensp;product&ensp;is&ensp;with&ensp;the&ensp;first&ensp;axis&ensp;of<br>  the&ensp;right-hand&ensp;side&ensp;tensor.&ensp;For&ensp;example&ensp;`fromLiteral&ensp;[0,&ensp;1,&ensp;2]&ensp;@@&ensp;fromLiteral&ensp;[-1,&ensp;-3,&ensp;-1]`&ensp;is<br>  `-1`.<br>  <br>  **WARNING**&ensp;Not&ensp;well&ensp;tested</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infixl&ensp;operator,&ensp;level&ensp;9</dd><dt id="Tensor.Matrix.@@"><code><span class="type resolved" title="Tensor.Matrix.@@"><span class="name function">(@@)</span></span>&ensp;:&ensp;(<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">dtype</span>,&ensp;<a class="type" href="Primitive.html#Primitive.Num"><span class="name type">Num</span></a>&ensp;<span class="boundvar">dtype</span>)&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">n</span>,&ensp;<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">m</span>]&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;(<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">m</span>&ensp;<span class="type resolved" title="Prelude.Basics.::"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">tl</span>)&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Data.Nat.LTE"><span class="name type">LTE</span></span>&ensp;(<span class="type resolved" title="Prelude.Types.List.length"><span class="name function">length</span></span>&ensp;<span class="boundvar">tl</span>)&ensp;<span class="name constructor">1</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;(<span class="boundvar">n</span>&ensp;<span class="type resolved" title="Prelude.Basics.::"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">tl</span>)&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Matrix&ensp;multiplication&ensp;with&ensp;a&ensp;matrix&ensp;or&ensp;vector.&ensp;Contraction&ensp;is&ensp;along&ensp;the&ensp;last&ensp;axis&ensp;of&ensp;the&ensp;first<br>  and&ensp;the&ensp;first&ensp;axis&ensp;of&ensp;the&ensp;last.&ensp;For&ensp;example:<br>  <br>  ```idris<br>  x&ensp;:&ensp;Tensor&ensp;[2,&ensp;3]&ensp;S32<br>  x&ensp;=&ensp;fromLiteral&ensp;[[-1,&ensp;-2,&ensp;-3],&ensp;[0,&ensp;1,&ensp;2]]<br>  <br>  y&ensp;:&ensp;Tensor&ensp;[3,&ensp;1]&ensp;S32<br>  y&ensp;=&ensp;fromLiteral&ensp;[[4,&ensp;0,&ensp;5]]<br>  <br>  z&ensp;:&ensp;Tensor&ensp;[2,&ensp;1]&ensp;S32<br>  z&ensp;=&ensp;x&ensp;@@&ensp;y<br>  ```<br>  <br>  is<br>  <br>  ```idris<br>  z&ensp;:&ensp;Tensor&ensp;[2,&ensp;1]&ensp;S32<br>  z&ensp;=&ensp;fromLiteral&ensp;[-19,&ensp;10]<br>  ```<br>  <br>  **WARNING**&ensp;Not&ensp;well&ensp;tested</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infixl&ensp;operator,&ensp;level&ensp;9</dd><dt id="Tensor.+"><code><a class="type" href="Tensor.html#Tensor.+"><span class="name function">(+)</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Num"><span class="name type">Num</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Element-wise&ensp;addition.&ensp;For&ensp;example,&ensp;`fromLiteral&ensp;[1,&ensp;2]&ensp;+&ensp;fromLiteral&ensp;[3,&ensp;4]`&ensp;is<br>  `fromLiteral&ensp;[4,&ensp;6]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infixl&ensp;operator,&ensp;level&ensp;8</dd><dt id="Tensor.negate"><code><a class="type" href="Tensor.html#Tensor.negate"><span class="name function">negate</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Neg"><span class="name type">Neg</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Element-wise&ensp;negation.&ensp;For&ensp;example,&ensp;`-&ensp;fromLiteral&ensp;[1,&ensp;-2]`&ensp;is&ensp;`fromLiteral&ensp;[-1,&ensp;2]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;prefix operator, level&ensp;10</dd><dt id="Prelude.Num.negate"><code><span class="type resolved" title="Prelude.Num.negate"><span class="name function">negate</span></span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Num.Neg"><span class="name type">Neg</span></span>&ensp;<span class="boundvar">ty</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">ty</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">ty</span></code></dt><dd><pre>  The&ensp;underlying&ensp;of&ensp;unary&ensp;minus.&ensp;`-5`&ensp;desugars&ensp;to&ensp;`negate&ensp;(fromInteger&ensp;5)`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Fixity Declaration</b>:&ensp;prefix operator, level&ensp;10</dd><dt id="Tensor.-"><code><a class="type" href="Tensor.html#Tensor.-"><span class="name function">(-)</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Neg"><span class="name type">Neg</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Element-wise&ensp;subtraction.&ensp;For&ensp;example,&ensp;`fromLiteral&ensp;[3,&ensp;4]&ensp;-&ensp;fromLiteral&ensp;[4,&ensp;2]`&ensp;is<br>  `fromLiteral&ensp;[-1,&ensp;2]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declarations</b>:<br>  infixl&ensp;operator,&ensp;level&ensp;8<br>prefix operator, level&ensp;10</dd><dt id="Tensor.*"><code><a class="type" href="Tensor.html#Tensor.*"><span class="name function">(*)</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Num"><span class="name type">Num</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Element-wise&ensp;multiplication.&ensp;For&ensp;example,&ensp;`fromLiteral&ensp;[2,&ensp;3]&ensp;*&ensp;fromLiteral&ensp;[4,&ensp;5]`&ensp;is<br>  `fromLiteral&ensp;[8,&ensp;15]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infixl&ensp;operator,&ensp;level&ensp;9</dd><dt id="Tensor.Scalarwise.*"><code><span class="type resolved" title="Tensor.Scalarwise.*"><span class="name function">(*)</span></span>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Num"><span class="name type">Num</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;(<span class="boundvar">d</span>&ensp;<span class="type resolved" title="Prelude.Basics.::"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">ds</span>)&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;(<span class="boundvar">d</span>&ensp;<span class="type resolved" title="Prelude.Basics.::"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">ds</span>)&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Multiplication&ensp;by&ensp;a&ensp;scalar.&ensp;For&ensp;example,&ensp;`fromLiteral&ensp;2&ensp;*&ensp;fromLiteral&ensp;[3,&ensp;5]`&ensp;is<br>  `fromLiteral&ensp;[6,&ensp;10]`.<br>  <br>  The&ensp;RHS&ensp;is&ensp;required&ensp;to&ensp;be&ensp;non-scalar&ensp;simply&ensp;to&ensp;avoid&ensp;ambiguities&ensp;with&ensp;element-wise&ensp;`(*)`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infixl&ensp;operator,&ensp;level&ensp;9</dd><dt id="Tensor./"><code><a class="type" href="Tensor.html#Tensor./"><span class="name function">(/)</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Fractional"><span class="name type">Fractional</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Element-wise&ensp;floating&ensp;point&ensp;division.&ensp;For&ensp;example,&ensp;`fromLiteral&ensp;[2,&ensp;3]&ensp;/&ensp;fromLiteral&ensp;[4,&ensp;5]`&ensp;is<br>  `fromLiteral&ensp;[0.5,&ensp;0.6]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infixl&ensp;operator,&ensp;level&ensp;9</dd><dt id="Tensor.Scalarwise./"><code><span class="type resolved" title="Tensor.Scalarwise./"><span class="name function">(/)</span></span>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Fractional"><span class="name type">Fractional</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;(<span class="boundvar">d</span>&ensp;<span class="type resolved" title="Prelude.Basics.::"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">ds</span>)&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;(<span class="boundvar">d</span>&ensp;<span class="type resolved" title="Prelude.Basics.::"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">ds</span>)&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Floating&ensp;point&ensp;division&ensp;by&ensp;a&ensp;scalar.&ensp;For&ensp;example,&ensp;`fromLiteral&ensp;[3.4,&ensp;-5.6]&ensp;/&ensp;fromLiteral&ensp;2`&ensp;is<br>  `fromLiteral&ensp;[1.7,&ensp;-2.8]`.<br>  <br>  The&ensp;LHS&ensp;is&ensp;required&ensp;to&ensp;be&ensp;non-scalar&ensp;simply&ensp;to&ensp;avoid&ensp;ambiguities&ensp;with&ensp;element-wise&ensp;`(/)`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infixl&ensp;operator,&ensp;level&ensp;9</dd><dt id="Tensor.recip"><code><a class="type" href="Tensor.html#Tensor.recip"><span class="name function">recip</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The&ensp;element-wise&ensp;reciprocal.&ensp;For&ensp;example,&ensp;`recip&ensp;(fromLiteral&ensp;[-2,&ensp;0,&ensp;0.2])`<br>  is&ensp;`fromLiteral&ensp;[-0.5,&ensp;nan,&ensp;5]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.^"><code><a class="type" href="Tensor.html#Tensor.^"><span class="name function">(^)</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  Each&ensp;element&ensp;in&ensp;`base`&ensp;raised&ensp;to&ensp;the&ensp;power&ensp;of&ensp;the&ensp;corresponding&ensp;element&ensp;in&ensp;`exponent`.<br>  example,&ensp;`fromLiteral&ensp;[2,&ensp;25,&ensp;-9]&ensp;^&ensp;fromLiteral&ensp;[3,&ensp;-0.5,&ensp;0.5]`&ensp;is&ensp;`fromLiteral&ensp;[8,&ensp;0.2,&ensp;nan]`.<br>  <br>  Note:&ensp;The&ensp;behaviour&ensp;of&ensp;this&ensp;function&ensp;is&ensp;not&ensp;well-defined&ensp;at&ensp;negative&ensp;or&ensp;positive&ensp;infinity,&ensp;or<br>  NaN.<br>  <br>  Note:&ensp;The&ensp;first&ensp;root&ensp;is&ensp;used.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infixr&ensp;operator,&ensp;level&ensp;9</dd><dt id="Tensor.abs"><code><a class="type" href="Tensor.html#Tensor.abs"><span class="name function">abs</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Abs"><span class="name type">Abs</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Element-wise&ensp;absolute&ensp;value.&ensp;For&ensp;example,&ensp;`abs&ensp;(fromLiteral&ensp;[-2,&ensp;3])`&ensp;is<br>  `fromLiteral&ensp;[2,&ensp;3]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.exp"><code><a class="type" href="Tensor.html#Tensor.exp"><span class="name function">exp</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The&ensp;element-wise&ensp;natural&ensp;exponential.&ensp;For&ensp;example,&ensp;`exp&ensp;(fromLiteral&ensp;[-1,&ensp;0,&ensp;2])`&ensp;is<br>  `fromLiteral&ensp;[1&ensp;/&ensp;euler,&ensp;1,&ensp;pow&ensp;euler&ensp;2]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.floor"><code><a class="type" href="Tensor.html#Tensor.floor"><span class="name function">floor</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The&ensp;element-wise&ensp;floor&ensp;function.&ensp;For&ensp;example,<br>  `floor&ensp;(fromLiteral&ensp;[-1.6,&ensp;-1.5,&ensp;-1.4,&ensp;-1.0,&ensp;1.0,&ensp;1.4,&ensp;1.5,&ensp;1.6])`&ensp;is<br>  `fromLiteral&ensp;[-2.0,&ensp;-2.0,&ensp;-2.0,&ensp;-1.0,&ensp;1.0,&ensp;1.0,&ensp;1.0,&ensp;1.0]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.ceil"><code><a class="type" href="Tensor.html#Tensor.ceil"><span class="name function">ceil</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The&ensp;element-wise&ensp;ceiling&ensp;function.&ensp;For&ensp;example,<br>  `ceil&ensp;(fromLiteral&ensp;[-1.6,&ensp;-1.5,&ensp;-1.4,&ensp;-1.0,&ensp;1.0,&ensp;1.4,&ensp;1.5,&ensp;1.6])`&ensp;is<br>  `fromLiteral&ensp;[-1.0,&ensp;-1.0,&ensp;-1.0,&ensp;-1.0,&ensp;1.0,&ensp;2.0,&ensp;2.0,&ensp;2.0]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.log"><code><a class="type" href="Tensor.html#Tensor.log"><span class="name function">log</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The&ensp;element-wise&ensp;natural&ensp;logarithm.&ensp;Negative&ensp;inputs&ensp;yield&ensp;NaN&ensp;output.&ensp;For&ensp;example,<br>  `log&ensp;(fromLiteral&ensp;[1&ensp;/&ensp;euler,&ensp;1,&ensp;euler&ensp;*&ensp;euler])`&ensp;is&ensp;`fromLiteral&ensp;[-1,&ensp;0,&ensp;2]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.logistic"><code><a class="type" href="Tensor.html#Tensor.logistic"><span class="name function">logistic</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The&ensp;element-wise&ensp;logistic&ensp;function&ensp;equivalent&ensp;to&ensp;`1&ensp;/&ensp;1&ensp;+&ensp;exp&ensp;(-x)`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.sin"><code><a class="type" href="Tensor.html#Tensor.sin"><span class="name function">sin</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The&ensp;element-wise&ensp;sine.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.cos"><code><a class="type" href="Tensor.html#Tensor.cos"><span class="name function">cos</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The&ensp;element-wise&ensp;cosine.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.tan"><code><a class="type" href="Tensor.html#Tensor.tan"><span class="name function">tan</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The&ensp;element-wise&ensp;tangent.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.asin"><code><a class="type" href="Tensor.html#Tensor.asin"><span class="name function">asin</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The&ensp;element-wise&ensp;inverse&ensp;sine.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.acos"><code><a class="type" href="Tensor.html#Tensor.acos"><span class="name function">acos</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The&ensp;element-wise&ensp;inverse&ensp;cosine.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.atan"><code><a class="type" href="Tensor.html#Tensor.atan"><span class="name function">atan</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The&ensp;element-wise&ensp;inverse&ensp;tangent.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.sinh"><code><a class="type" href="Tensor.html#Tensor.sinh"><span class="name function">sinh</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The&ensp;element-wise&ensp;hyperbolic&ensp;sine.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.cosh"><code><a class="type" href="Tensor.html#Tensor.cosh"><span class="name function">cosh</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The&ensp;element-wise&ensp;hyperbolic&ensp;cosine.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.tanh"><code><a class="type" href="Tensor.html#Tensor.tanh"><span class="name function">tanh</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The&ensp;element-wise&ensp;hyperbolic&ensp;tangent.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.asinh"><code><a class="type" href="Tensor.html#Tensor.asinh"><span class="name function">asinh</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The&ensp;element-wise&ensp;inverse&ensp;hyperbolic&ensp;sine.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.acosh"><code><a class="type" href="Tensor.html#Tensor.acosh"><span class="name function">acosh</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The&ensp;element-wise&ensp;inverse&ensp;hyperbolic&ensp;cosine.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.atanh"><code><a class="type" href="Tensor.html#Tensor.atanh"><span class="name function">atanh</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The&ensp;element-wise&ensp;inverse&ensp;hyperbolic&ensp;tangent.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.erf"><code><a class="type" href="Tensor.html#Tensor.erf"><span class="name function">erf</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  An&ensp;approximation&ensp;to&ensp;the&ensp;element-wise&ensp;error&ensp;function.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.square"><code><a class="type" href="Tensor.html#Tensor.square"><span class="name function">square</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The&ensp;element-wise&ensp;square.&ensp;For&ensp;example,&ensp;`square&ensp;(fromLiteral&ensp;[-2,&ensp;0,&ensp;3])`<br>  is&ensp;`fromLiteral&ensp;[4,&ensp;0,&ensp;9]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.sqrt"><code><a class="type" href="Tensor.html#Tensor.sqrt"><span class="name function">sqrt</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The&ensp;element-wise&ensp;square&ensp;root.&ensp;The&ensp;first&ensp;root&ensp;is&ensp;used.&ensp;Negative&ensp;inputs&ensp;yield&ensp;NaN&ensp;output.<br>  For&ensp;example,&ensp;`sqrt&ensp;(fromLiteral&ensp;[0,&ensp;9])`&ensp;is&ensp;`fromLiteral&ensp;[0,&ensp;3]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.min"><code><a class="type" href="Tensor.html#Tensor.min"><span class="name function">min</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Ord"><span class="name type">Ord</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  The&ensp;element-wise&ensp;minimum&ensp;of&ensp;the&ensp;first&ensp;argument&ensp;compared&ensp;to&ensp;the&ensp;second.&ensp;For&ensp;example,<br>  `min&ensp;(fromLiteral&ensp;[-3,&ensp;-1,&ensp;3])&ensp;(fromLiteral&ensp;[-1,&ensp;0,&ensp;1])`&ensp;is&ensp;`fromLiteral&ensp;[-3,&ensp;-1,&ensp;1]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.max"><code><a class="type" href="Tensor.html#Tensor.max"><span class="name function">max</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Ord"><span class="name type">Ord</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  The&ensp;element-wise&ensp;maximum&ensp;of&ensp;the&ensp;first&ensp;argument&ensp;compared&ensp;to&ensp;the&ensp;second.&ensp;For&ensp;example,<br>  `max&ensp;(fromLiteral&ensp;[-3,&ensp;-1,&ensp;3])&ensp;(fromLiteral&ensp;[-1,&ensp;0,&ensp;1])`&ensp;is&ensp;`fromLiteral&ensp;[-1,&ensp;0,&ensp;3]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.argmin"><code><a class="type" href="Tensor.html#Tensor.argmin"><span class="name function">argmin</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Ord"><span class="name type">Ord</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">n</span>]&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.U64"><span class="name type">U64</span></a></code></dt><dd><pre>  The&ensp;first&ensp;index&ensp;of&ensp;the&ensp;minimum&ensp;value&ensp;in&ensp;a&ensp;vector.&ensp;For&ensp;example,<br>  `argmin&ensp;(fromLiteral&ensp;[-1,&ensp;3,&ensp;-2,&ensp;-2,&ensp;3])`&ensp;is&ensp;`fromLiteral&ensp;2`.&ensp;If&ensp;the&ensp;vector&ensp;contains&ensp;NaN&ensp;values,<br>  `argmin`&ensp;returns&ensp;the&ensp;index&ensp;of&ensp;the&ensp;first&ensp;NaN.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.argmax"><code><a class="type" href="Tensor.html#Tensor.argmax"><span class="name function">argmax</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Ord"><span class="name type">Ord</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">n</span>]&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.U64"><span class="name type">U64</span></a></code></dt><dd><pre>  The&ensp;first&ensp;index&ensp;of&ensp;the&ensp;maximum&ensp;value&ensp;in&ensp;a&ensp;vector.&ensp;For&ensp;example,<br>  `argmin&ensp;(fromLiteral&ensp;[-1,&ensp;3,&ensp;-2,&ensp;-2,&ensp;3])`&ensp;is&ensp;`fromLiteral&ensp;1`.&ensp;If&ensp;the&ensp;vector&ensp;contains&ensp;NaN&ensp;values,<br>  `argmin`&ensp;returns&ensp;the&ensp;index&ensp;of&ensp;the&ensp;first&ensp;NaN.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.cholesky"><code><a class="type" href="Tensor.html#Tensor.cholesky"><span class="name function">cholesky</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">n</span>,&ensp;<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">n</span>]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">n</span>,&ensp;<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">n</span>]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  Cholesky&ensp;decomposition.&ensp;Computes&ensp;the&ensp;lower&ensp;triangular&ensp;matrix&ensp;`L`&ensp;from&ensp;the&ensp;symmetric,&ensp;positive<br>  semi-definite&ensp;matrix&ensp;`X`&ensp;s.t.&ensp;`X&ensp;=&ensp;L&ensp;@@&ensp;L.T`.&ensp;Values&ensp;will&ensp;be&ensp;NaN&ensp;if&ensp;the&ensp;input&ensp;matrix&ensp;is&ensp;not<br>  positive&ensp;semi-definite.&ensp;The&ensp;remaining&ensp;matrix&ensp;components&ensp;-&ensp;those&ensp;not&ensp;in&ensp;the&ensp;lower&ensp;triangle&ensp;or<br>  diagonal&ensp;-&ensp;will&ensp;always&ensp;be&ensp;zero.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.Matrix.|\"><code><span class="type resolved" title="Tensor.Matrix.|\"><span class="name function">(|\)</span></span>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">m</span>,&ensp;<span class="boundvar">m</span>]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">m</span>,&ensp;<span class="boundvar">n</span>]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">m</span>,&ensp;<span class="boundvar">n</span>]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  Solve&ensp;the&ensp;set&ensp;of&ensp;linear&ensp;equations&ensp;`a&ensp;@@&ensp;x&ensp;=&ensp;b`&ensp;for&ensp;`x`&ensp;where&ensp;`a`&ensp;is&ensp;a&ensp;lower-triangular&ensp;matrix.<br>  `a`&ensp;is&ensp;given&ensp;by&ensp;the&ensp;lower-triangular&ensp;elements&ensp;of&ensp;the&ensp;first&ensp;argument.&ensp;Values&ensp;in&ensp;the<br>  upper-triangular&ensp;part&ensp;are&ensp;ignored.&ensp;If&ensp;`a`&ensp;is&ensp;lower-triangular&ensp;already,<br>  this&ensp;is&ensp;written&ensp;`a&ensp;|\&ensp;b`.<br>  <br>  The&ensp;operator&ensp;is&ensp;shaped&ensp;like&ensp;the&ensp;lower-triangular&ensp;portion&ensp;of&ensp;a&ensp;matrix&ensp;to&ensp;signal&ensp;that&ensp;it&ensp;uses<br>  this&ensp;portion&ensp;of&ensp;its&ensp;argument.&ensp;This&ensp;is&ensp;in&ensp;contrast&ensp;to&ensp;`(\|)`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infix&ensp;operator,&ensp;level&ensp;9</dd><dt id="Tensor.Matrix.\|"><code><span class="type resolved" title="Tensor.Matrix.\|"><span class="name function">(\|)</span></span>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">m</span>,&ensp;<span class="boundvar">m</span>]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">m</span>,&ensp;<span class="boundvar">n</span>]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">m</span>,&ensp;<span class="boundvar">n</span>]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  Solve&ensp;the&ensp;set&ensp;of&ensp;linear&ensp;equations&ensp;`a&ensp;@@&ensp;x&ensp;=&ensp;b`&ensp;for&ensp;`x`&ensp;where&ensp;`a`&ensp;is&ensp;an&ensp;upper-triangular<br>  matrix.&ensp;`a`&ensp;is&ensp;given&ensp;by&ensp;the&ensp;upper-triangular&ensp;elements&ensp;of&ensp;the&ensp;first&ensp;argument.&ensp;Values&ensp;in&ensp;the<br>  lower-triangular&ensp;part&ensp;are&ensp;ignored.&ensp;If&ensp;`a`&ensp;is&ensp;upper-triangular&ensp;already,&ensp;this&ensp;is&ensp;written<br>  `a&ensp;\|&ensp;b`.<br>  <br>  The&ensp;operator&ensp;is&ensp;shaped&ensp;like&ensp;the&ensp;upper-triangular&ensp;portion&ensp;of&ensp;a&ensp;matrix&ensp;to&ensp;signal&ensp;that&ensp;it&ensp;uses<br>  this&ensp;portion&ensp;of&ensp;its&ensp;argument.&ensp;This&ensp;is&ensp;in&ensp;contrast&ensp;to&ensp;`(|\)`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infix&ensp;operator,&ensp;level&ensp;9</dd><dt id="Tensor.Vector.|\"><code><span class="type resolved" title="Tensor.Vector.|\"><span class="name function">(|\)</span></span>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">m</span>,&ensp;<span class="boundvar">m</span>]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">m</span>]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">m</span>]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  Solve&ensp;the&ensp;set&ensp;of&ensp;linear&ensp;equations&ensp;`a&ensp;@@&ensp;x&ensp;=&ensp;b`&ensp;for&ensp;`x`&ensp;where&ensp;`a`&ensp;is&ensp;a&ensp;lower-triangular&ensp;matrix.<br>  `a`&ensp;is&ensp;given&ensp;by&ensp;the&ensp;lower-triangular&ensp;elements&ensp;of&ensp;the&ensp;first&ensp;argument.&ensp;Values&ensp;in&ensp;the<br>  upper-triangular&ensp;part&ensp;are&ensp;ignored.&ensp;If&ensp;`a`&ensp;is&ensp;lower-triangular&ensp;already,<br>  this&ensp;is&ensp;written&ensp;`a&ensp;|\&ensp;b`.<br>  <br>  The&ensp;operator&ensp;is&ensp;shaped&ensp;like&ensp;the&ensp;lower-triangular&ensp;portion&ensp;of&ensp;a&ensp;matrix&ensp;to&ensp;signal&ensp;that&ensp;it&ensp;uses<br>  this&ensp;portion&ensp;of&ensp;its&ensp;argument.&ensp;This&ensp;is&ensp;in&ensp;contrast&ensp;to&ensp;`(\|)`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infix&ensp;operator,&ensp;level&ensp;9</dd><dt id="Tensor.Vector.\|"><code><span class="type resolved" title="Tensor.Vector.\|"><span class="name function">(\|)</span></span>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">m</span>,&ensp;<span class="boundvar">m</span>]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">m</span>]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">m</span>]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  Solve&ensp;the&ensp;set&ensp;of&ensp;linear&ensp;equations&ensp;`a&ensp;@@&ensp;x&ensp;=&ensp;b`&ensp;for&ensp;`x`&ensp;where&ensp;`a`&ensp;is&ensp;an&ensp;upper-triangular<br>  matrix.&ensp;`a`&ensp;is&ensp;given&ensp;by&ensp;the&ensp;upper-triangular&ensp;elements&ensp;of&ensp;the&ensp;first&ensp;argument.&ensp;Values&ensp;in&ensp;the<br>  lower-triangular&ensp;part&ensp;are&ensp;ignored.&ensp;If&ensp;`a`&ensp;is&ensp;upper-triangular&ensp;already,&ensp;this&ensp;is&ensp;written<br>  `a&ensp;\|&ensp;b`.<br>  <br>  The&ensp;operator&ensp;is&ensp;shaped&ensp;like&ensp;the&ensp;upper-triangular&ensp;portion&ensp;of&ensp;a&ensp;matrix&ensp;to&ensp;signal&ensp;that&ensp;it&ensp;uses<br>  this&ensp;portion&ensp;of&ensp;its&ensp;argument.&ensp;This&ensp;is&ensp;in&ensp;contrast&ensp;to&ensp;`(|\)`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infix&ensp;operator,&ensp;level&ensp;9</dd><dt id="Tensor.trace"><code><a class="type" href="Tensor.html#Tensor.trace"><span class="name function">trace</span></a>&ensp;:&ensp;(<a class="type" href="Primitive.html#Primitive.Num"><span class="name type">Num</span></a>&ensp;<span class="boundvar">dtype</span>,&ensp;<span class="type resolved" title="Prelude.Num.Num"><span class="name type">Num</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Primitive.html#Primitive.PrimitiveRW"><span class="name type">PrimitiveRW</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">n</span>,&ensp;<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">n</span>]&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Sum&ensp;the&ensp;elements&ensp;along&ensp;the&ensp;diagonal&ensp;of&ensp;the&ensp;input.&ensp;For&ensp;example,<br>  `trace&ensp;(fromLiteral&ensp;[[-1,&ensp;5],&ensp;[1,&ensp;4]])`&ensp;is&ensp;`3`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.Rand"><code><a class="type" href="Tensor.html#Tensor.Rand"><span class="name function">Rand</span></a>&ensp;:&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  A&ensp;`Rand&ensp;a`&ensp;produces&ensp;a&ensp;pseudo-random&ensp;value&ensp;of&ensp;type&ensp;`a`&ensp;from&ensp;a&ensp;`Tensor&ensp;[1]&ensp;U64`&ensp;state.<br>  The&ensp;state&ensp;is&ensp;updated&ensp;each&ensp;time&ensp;a&ensp;new&ensp;value&ensp;is&ensp;generated.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Tensor.uniform"><code><a class="type" href="Tensor.html#Tensor.uniform"><span class="name function">uniform</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.U64"><span class="name type">U64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Rand"><span class="name function">Rand</span></a>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>)</code></dt><dd><pre>  Generate&ensp;independent&ensp;and&ensp;identically&ensp;distributed&ensp;(IID)&ensp;uniform&ensp;samples&ensp;bounded&ensp;element-wise<br>  between&ensp;`bound`&ensp;and&ensp;`bound&apos;`.<br>  <br>  `bound`&ensp;and&ensp;`bound&apos;`&ensp;need&ensp;not&ensp;be&ensp;ordered,&ensp;and&ensp;samples&ensp;will&ensp;be&ensp;generated,&ensp;elementwise,&ensp;in<br>  [min&ensp;bound&ensp;bound&apos;,&ensp;max&ensp;bound&ensp;bound&apos;).&ensp;The&ensp;exception&ensp;is&ensp;where&ensp;the&ensp;bounds&ensp;are&ensp;equal,&ensp;in&ensp;which<br>  case:&ensp;if&ensp;the&ensp;bounds&ensp;are&ensp;finite,&ensp;samples&ensp;are&ensp;generated&ensp;at&ensp;the&ensp;common&ensp;bound,&ensp;else&ensp;samples&ensp;are&ensp;NaN.<br>  <br>  The&ensp;generated&ensp;samples&ensp;are&ensp;a&ensp;deterministic&ensp;function&ensp;of&ensp;the&ensp;input&ensp;key&ensp;and&ensp;state,&ensp;but&ensp;may&ensp;vary<br>  between&ensp;backends&ensp;and&ensp;library&ensp;versions.<br>  <br>  Example&ensp;usage,&ensp;multiplying&ensp;two&ensp;uniform&ensp;samples<br>  ```<br>  x&ensp;:&ensp;Tensor&ensp;[3]&ensp;F64<br>  x&ensp;=&ensp;let&ensp;key&ensp;=&ensp;fromLiteral&ensp;2<br>  rng&ensp;=&ensp;uniform&ensp;key&ensp;(fill&ensp;0.0)&ensp;(fill&ensp;1.0)<br>  initialState&ensp;=&ensp;fromLiteral&ensp;[0]<br>  in&ensp;evalState&ensp;initialState&ensp;[|&ensp;rng&ensp;*&ensp;rng&ensp;|]<br>  ```<br>  <br>  @key&ensp;Determines&ensp;the&ensp;stream&ensp;of&ensp;generated&ensp;samples.<br>  @bound&ensp;A&ensp;bound&ensp;of&ensp;the&ensp;samples.&ensp;See&ensp;full&ensp;docstring&ensp;for&ensp;details.<br>  @bound&apos;&ensp;A&ensp;bound&ensp;of&ensp;the&ensp;samples.&ensp;See&ensp;full&ensp;docstring&ensp;for&ensp;details.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.normal"><code><a class="type" href="Tensor.html#Tensor.normal"><span class="name function">normal</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.U64"><span class="name type">U64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Rand"><span class="name function">Rand</span></a>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>)</code></dt><dd><pre>  Generate&ensp;independent&ensp;and&ensp;identically&ensp;distributed&ensp;(IID)&ensp;samples&ensp;from&ensp;the&ensp;standard&ensp;normal<br>  distribution.<br>  <br>  The&ensp;generated&ensp;samples&ensp;are&ensp;a&ensp;deterministic&ensp;function&ensp;of&ensp;the&ensp;input&ensp;key&ensp;and&ensp;state,&ensp;but&ensp;may&ensp;vary<br>  between&ensp;backends&ensp;and&ensp;library&ensp;versions.<br>  <br>  Example&ensp;usage,&ensp;multiplying&ensp;two&ensp;normal&ensp;samples<br>  ```<br>  x&ensp;:&ensp;Tensor&ensp;[3]&ensp;F64<br>  x&ensp;=&ensp;let&ensp;key&ensp;=&ensp;fromLiteral&ensp;2<br>  rng&ensp;=&ensp;normal&ensp;key<br>  initialState&ensp;=&ensp;fromLiteral&ensp;[0]<br>  in&ensp;evalState&ensp;initialState&ensp;[|&ensp;rng&ensp;*&ensp;rng&ensp;|]<br>  ```<br>  <br>  @key&ensp;Determines&ensp;the&ensp;stream&ensp;of&ensp;generated&ensp;samples.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd></dl></div><footer>Produced by Idris 2 version 0.5.1-f03f184af</footer></body></html>
