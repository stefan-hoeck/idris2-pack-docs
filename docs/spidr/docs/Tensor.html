<!DOCTYPE html><html lang="en">

<head>
  <meta charset="utf-8">
  <title>Tensor</title>
  <link rel="stylesheet" type="text/css" id="preferredStyle" href="../default.css">
  <script>
    /* Updates the stylesheet to use the preferred one.
       Note that we set the link to root ++ sourceLoc because the config
       is shared across the whole website, so the root may differ from
       page to page.
    */
    function setStyleSource (sourceLoc) {
      document.getElementById("preferredStyle").href = "../" + sourceLoc + ".css";
      document.getElementById("selectPreferredStyle").value = sourceLoc;
    }
    /* Initialises the preferred style sheet:
       1. if there is a stored value then use that
          otherwise select the default
       2. set both the css link href & the drop down menu selected option
    */
    function initStyleSource () {
      var preferredStyle = localStorage.getItem("stylefile");
      if (preferredStyle !== null) {
        setStyleSource(preferredStyle);
      } else {
        setStyleSource("default");
      };
    }
    function saveStyleSource (preferredStyle) {
      localStorage.stylefile = preferredStyle;
    }
    </script>
</head>

<body class="namespace">
<header>
  <strong>Idris2Doc</strong> : Tensor
  <nav><a href="../index.html">Index</a>

  <select id="selectPreferredStyle">
    <option value="default">Default</option>
<option value="alternative">Alternative</option>
<option value="blackandwhite">Black & White</option>

  </select>
  </nav>

  <script>
  /* We start by initialising the style source */
  initStyleSource();

  /* This listens for changes on the drop down menu and updates the
     css used for the current page when a selection is made.
  */
  document.getElementById("selectPreferredStyle").addEventListener("change", function(){
    var selected = this.options[this.selectedIndex].value; /* the option chosen */
    setStyleSource (selected);
    saveStyleSource (selected);
  });
</script>

</header>
<div class="container"><div id="module-header"><h1>Tensor</h1><span style="float:right">(<a href="Tensor.src.html">source</a>)</span><pre>This module contains the `Tensor` object, an array of numbers or booleans, along with a
number of functions operating on `Tensor`s.
</pre></div><h2>Reexports</h2><code><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Data.List<br><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Data.List.Elem<br><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Primitive<br><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Types<br><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Util</code><h2>Definitions</h2><dl class="decls"><dt id="Tensor.Tensor"><code><span class="keyword">data</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;:&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<a class="type" href="Types.html#Types.Shape"><span class="name function">Shape</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  A `Tensor` is a symbolic value, which may refer to either to a scalar value or array of values,<br>  though the runtime representation will likely contain more than its value, and will depend on<br>  the specific backend.<br>  <br>  @shape The `Tensor` shape.<br>  @dtype The element type.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Constructor</b>:&ensp;<dl class="decls"><dt id="Tensor.MkTensor"><code><a class="type" href="Tensor.html#Tensor.MkTensor"><span class="name constructor">MkTensor</span></a>&ensp;:&ensp;<a class="type" href="Compiler.Expr.html#Compiler.Expr.Expr"><span class="name type">Expr</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt></dl><br>  <b>Hints</b>:<br><dl class="decls">  <dt id="$resolved405"><code><a class="type" href="Primitive.html#Primitive.Integral"><span class="name type">Integral</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Cast.Cast"><span class="name type">Cast</span></span>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">a</span>)&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>)</code></dt>  <dt id="$resolved404"><code><span class="type resolved" title="Prelude.Show.Show"><span class="name type">Show</span></span>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>)</code></dt></dl></dd><dt id="Tensor.fromLiteral"><code><a class="type" href="Tensor.html#Tensor.fromLiteral"><span class="name function">fromLiteral</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.PrimitiveRW"><span class="name type">PrimitiveRW</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Literal.html#Literal.Literal"><span class="name type">Literal</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Construct a `Tensor` from `Literal` data.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.F64.fromDouble"><code><span class="type resolved" title="Tensor.F64.fromDouble"><span class="name function">fromDouble</span></span>&ensp;:&ensp;<span class="name type">Double</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.S32.fromInteger"><code><span class="type resolved" title="Tensor.S32.fromInteger"><span class="name function">fromInteger</span></span>&ensp;:&ensp;<span class="name type">Integer</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.S32"><span class="name type">S32</span></a></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.toLiteral"><code><a class="type" href="Tensor.html#Tensor.toLiteral"><span class="name function">toLiteral</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.PrimitiveRW"><span class="name type">PrimitiveRW</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="boundvar">ty</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Literal.html#Literal.Literal"><span class="name type">Literal</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">ty</span></code></dt><dd><pre>  Evaluate a `Tensor`, returning its value as a `Literal`. This function builds and executes the<br>  computation graph.<br>  <br>  This function will execute the graph on GPU if one is found, else it will use the host CPU.<br>  <br>  **Note:**<br>  * Each call to `toLiteral` will rebuild and execute the graph. Similarly, multiple calls to <br>    `toLiteral` on different `Tensor`s in a computation will be treated entirely independently.<br>    `toLiteral` does not store intermediate values. This is a known limitation, and may change in<br>    the future.<br>  * `toLiteral` performs logging as a side effect. You can disable this by adjusting the<br>    TensorFlow logging level e.g. with `export TF_CPP_MIN_LOG_LEVEL=3`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.reshape"><code><a class="type" href="Tensor.html#Tensor.reshape"><span class="name function">reshape</span></a>&ensp;:&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Interfaces.product"><span class="name function">product</span></span>&ensp;<span class="boundvar">from</span>&ensp;<span class="keyword">=</span>&ensp;<span class="type resolved" title="Prelude.Interfaces.product"><span class="name function">product</span></span>&ensp;<span class="boundvar">to</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">from</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">to</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Reshape a `Tensor`. For example, `reshape {to=[2, 1]} (fromLiteral [3, 4])` is<br>  `fromLiteral [[3], [4]]`. The output can have a different rank to the input.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.expand"><code><a class="type" href="Tensor.html#Tensor.expand"><span class="name function">expand</span></a>&ensp;:&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">axis</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">inBounds</span>&ensp;:&ensp;<span class="type resolved" title="Data.Nat.LTE"><span class="name type">LTE</span></span>&ensp;<span class="boundvar">axis</span>&ensp;(<span class="type resolved" title="Prelude.Types.List.length"><span class="name function">length</span></span>&ensp;<span class="boundvar">shape</span>)}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;(<span class="type resolved" title="Data.List.insertAt"><span class="name function">insertAt</span></span>&ensp;<span class="boundvar">axis</span>&ensp;<span class="name constructor">1</span>&ensp;<span class="boundvar">shape</span>)&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Add a dimension of length one at the specified `axis`. The new dimension will be at the<br>  specified `axis` in the new `Tensor` (as opposed to the original `Tensor`). For example,<br>  `expand 1 $ fromLiteral [[1, 2], [3, 4], [5, 6]]` is<br>  `fromLiteral [[[1, 2]], [[3, 4]], [[5, 6]]]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.Squeezable.Squeezable"><code><span class="keyword">data</span>&ensp;<span class="type resolved" title="Tensor.Squeezable.Squeezable"><span class="name type">Squeezable</span></span>&ensp;:&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<a class="type" href="Types.html#Types.Shape"><span class="name function">Shape</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<a class="type" href="Types.html#Types.Shape"><span class="name function">Shape</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  A `Squeezable from to` constitutes proof that the shape `from` can be squeezed to the<br>  shape `to`. Squeezing is the process of removing any number of dimensions of length one.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Constructors</b>:<br><dl class="decls">  <dt id="Tensor.Squeezable.Same"><code><span class="type resolved" title="Tensor.Squeezable.Same"><span class="name constructor">Same</span></span>&ensp;:&ensp;<span class="type resolved" title="Tensor.Squeezable.Squeezable"><span class="name type">Squeezable</span></span>&ensp;<span class="boundvar">x</span>&ensp;<span class="boundvar">x</span></code></dt><dd><pre>  Proof that a shape can be squeezed to itself. For example:<br>  <br>  [] to []<br>  [3, 4] to [3, 4]</pre></dd>  <dt id="Tensor.Squeezable.Match"><code><span class="type resolved" title="Tensor.Squeezable.Match"><span class="name constructor">Match</span></span>&ensp;:&ensp;<span class="type resolved" title="Tensor.Squeezable.Squeezable"><span class="name type">Squeezable</span></span>&ensp;<span class="boundvar">from</span>&ensp;<span class="boundvar">to</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Tensor.Squeezable.Squeezable"><span class="name type">Squeezable</span></span>&ensp;(<span class="boundvar">x</span>&ensp;<span class="type resolved" title="Prelude.Basics.::"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">from</span>)&ensp;(<span class="boundvar">x</span>&ensp;<span class="type resolved" title="Prelude.Basics.::"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">to</span>)</code></dt><dd><pre>  Proof that any dimensions (including those of length 1) can be preserved in the process of<br>  squeezing. For example:<br>  <br>  ...</pre></dd>  <dt id="Tensor.Squeezable.Nest"><code><span class="type resolved" title="Tensor.Squeezable.Nest"><span class="name constructor">Nest</span></span>&ensp;:&ensp;<span class="type resolved" title="Tensor.Squeezable.Squeezable"><span class="name type">Squeezable</span></span>&ensp;<span class="boundvar">from</span>&ensp;<span class="boundvar">to</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Tensor.Squeezable.Squeezable"><span class="name type">Squeezable</span></span>&ensp;(<span class="name constructor">1</span>&ensp;<span class="type resolved" title="Prelude.Basics.::"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">from</span>)&ensp;<span class="boundvar">to</span></code></dt><dd><pre>  Proof that any dimensions of length one can be squeezed out. For example:<br>  <br>  [1, 3, 1, 1, 4] to [3, 4]</pre></dd></dl></dd><dt id="Tensor.squeeze"><code><a class="type" href="Tensor.html#Tensor.squeeze"><span class="name function">squeeze</span></a>&ensp;:&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Tensor.Squeezable.Squeezable"><span class="name type">Squeezable</span></span>&ensp;<span class="boundvar">from</span>&ensp;<span class="boundvar">to</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">from</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">to</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Remove dimensions of length one from a `Tensor` such that it has the desired shape. For example:<br>  <br>  ```idris<br>  x : Tensor [2, 1, 3, 1] S32<br>  x = fromLiteral [[[[4], [5], [6]]], [[[7], [8], [9]]]]<br>  <br>  y : Tensor [2, 1, 3] S32<br>  y = squeeze x<br>  ```<br>  <br>  is<br>  <br>  ```idris<br>  y : Tensor [2, 1, 3] S32<br>  y = fromLiteral [[[4, 5, 6]], [[7, 8, 9]]]<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.SliceOrIndex"><code><span class="keyword">data</span>&ensp;<a class="type" href="Tensor.html#Tensor.SliceOrIndex"><span class="name type">SliceOrIndex</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  A `SliceOrIndex d` is a valid slice or index into a dimension of size `d`. See `slice` for<br>  details.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Constructors</b>:<br><dl class="decls">  <dt id="Tensor.Slice"><code><a class="type" href="Tensor.html#Tensor.Slice"><span class="name constructor">Slice</span></a>&ensp;:&ensp;(<span class="boundvar">from</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">to</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="boundvar">from</span>&ensp;<span class="type resolved" title="Prelude.Num.+"><span class="name function">+</span></span>&ensp;<span class="boundvar">size</span>&ensp;<span class="keyword">=</span>&ensp;<span class="boundvar">to</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Data.Nat.LTE"><span class="name type">LTE</span></span>&ensp;<span class="boundvar">to</span>&ensp;<span class="boundvar">d</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.SliceOrIndex"><span class="name type">SliceOrIndex</span></a>&ensp;<span class="boundvar">d</span></code></dt>  <dt id="Tensor.Index"><code><a class="type" href="Tensor.html#Tensor.Index"><span class="name constructor">Index</span></a>&ensp;:&ensp;(<span class="boundvar">idx</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Data.Nat.LT"><span class="name function">LT</span></span>&ensp;<span class="boundvar">idx</span>&ensp;<span class="boundvar">d</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.SliceOrIndex"><span class="name type">SliceOrIndex</span></a>&ensp;<span class="boundvar">d</span></code></dt>  <dt id="Tensor.DynamicSlice"><code><a class="type" href="Tensor.html#Tensor.DynamicSlice"><span class="name constructor">DynamicSlice</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.U64"><span class="name type">U64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">size</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Data.Nat.LTE"><span class="name type">LTE</span></span>&ensp;<span class="boundvar">size</span>&ensp;<span class="boundvar">d</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.SliceOrIndex"><span class="name type">SliceOrIndex</span></a>&ensp;<span class="boundvar">d</span></code></dt>  <dt id="Tensor.DynamicIndex"><code><a class="type" href="Tensor.html#Tensor.DynamicIndex"><span class="name constructor">DynamicIndex</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.U64"><span class="name type">U64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.SliceOrIndex"><span class="name type">SliceOrIndex</span></a>&ensp;<span class="boundvar">d</span></code></dt></dl></dd><dt id="Tensor.at"><code><a class="type" href="Tensor.html#Tensor.at"><span class="name function">at</span></a>&ensp;:&ensp;(<span class="boundvar">idx</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Data.Nat.LT"><span class="name function">LT</span></span>&ensp;<span class="boundvar">idx</span>&ensp;<span class="boundvar">d</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.SliceOrIndex"><span class="name type">SliceOrIndex</span></a>&ensp;<span class="boundvar">d</span></code></dt><dd><pre>  Index at `idx`. See `slice` for details.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Tensor.Dynamic.at"><code><span class="type resolved" title="Tensor.Dynamic.at"><span class="name function">at</span></span>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.U64"><span class="name type">U64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.SliceOrIndex"><span class="name type">SliceOrIndex</span></a>&ensp;<span class="boundvar">d</span></code></dt><dd><pre>  Index at the specified index. See `slice` for details.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Tensor.(.to)"><code><a class="type" href="Tensor.html#Tensor.(.to)"><span class="name function">.to</span></a>&ensp;:&ensp;(<span class="boundvar">from</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">to</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="boundvar">from</span>&ensp;<span class="type resolved" title="Prelude.Num.+"><span class="name function">+</span></span>&ensp;<span class="boundvar">size</span>&ensp;<span class="keyword">=</span>&ensp;<span class="boundvar">to</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Data.Nat.LTE"><span class="name type">LTE</span></span>&ensp;<span class="boundvar">to</span>&ensp;<span class="boundvar">d</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.SliceOrIndex"><span class="name type">SliceOrIndex</span></a>&ensp;<span class="boundvar">d</span></code></dt><dd><pre>  Slice from `from` (inclusive) to `to` (exclusive). See `slice` for details.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Tensor.(.size)"><code><a class="type" href="Tensor.html#Tensor.(.size)"><span class="name function">.size</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.U64"><span class="name type">U64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">size</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Data.Nat.LTE"><span class="name type">LTE</span></span>&ensp;<span class="boundvar">size</span>&ensp;<span class="boundvar">d</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.SliceOrIndex"><span class="name type">SliceOrIndex</span></a>&ensp;<span class="boundvar">d</span></code></dt><dd><pre>  Slice `size` elements starting at the specified scalar `U64` index. See `slice` for details.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Tensor.all"><code><a class="type" href="Tensor.html#Tensor.all"><span class="name function">all</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.SliceOrIndex"><span class="name type">SliceOrIndex</span></a>&ensp;<span class="boundvar">d</span></code></dt><dd><pre>  Slice across all indices along an axis. See `slice` for details.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Tensor.MultiSlice"><code><span class="keyword">data</span>&ensp;<a class="type" href="Tensor.html#Tensor.MultiSlice"><span class="name type">MultiSlice</span></a>&ensp;:&ensp;<a class="type" href="Types.html#Types.Shape"><span class="name function">Shape</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  A `MultiSlice shape` is a valid multi-dimensionsal slice into a tensor with shape `shape`.<br>  See `slice` for details.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Constructors</b>:<br><dl class="decls">  <dt id="Tensor.Nil"><code><a class="type" href="Tensor.html#Tensor.Nil"><span class="name constructor">Nil</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.MultiSlice"><span class="name type">MultiSlice</span></a>&ensp;<span class="boundvar">ds</span></code></dt>  <dt id="Tensor.::"><code><a class="type" href="Tensor.html#Tensor.::"><span class="name constructor">(::)</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.SliceOrIndex"><span class="name type">SliceOrIndex</span></a>&ensp;<span class="boundvar">d</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.MultiSlice"><span class="name type">MultiSlice</span></a>&ensp;<span class="boundvar">ds</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.MultiSlice"><span class="name type">MultiSlice</span></a>&ensp;(<span class="boundvar">d</span>&ensp;<span class="type resolved" title="Prelude.Basics.::"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">ds</span>)</code></dt></dl></dd><dt id="Tensor.MultiSlice.slice"><code><span class="type resolved" title="Tensor.MultiSlice.slice"><span class="name function">slice</span></span>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.MultiSlice"><span class="name type">MultiSlice</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Types.html#Types.Shape"><span class="name function">Shape</span></a></code></dt><dd><pre>  The shape of a tensor produced by slicing with the specified multi-dimensional slice. See<br>  `Tensor.slice` for details.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Tensor.slice"><code><a class="type" href="Tensor.html#Tensor.slice"><span class="name function">slice</span></a>&ensp;:&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">at</span>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.MultiSlice"><span class="name type">MultiSlice</span></a>&ensp;<span class="boundvar">shape</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;(<span class="type resolved" title="Tensor.MultiSlice.slice"><span class="name function">slice</span></span>&ensp;<span class="boundvar">at</span>)&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Slice or index `Tensor` axes. Each axis can be sliced or indexed, and this can be done with<br>  either static (`Nat`) or dynamic (scalar `U64`) indices.<br>  <br>  **Static indices**<br>  <br>  Static indices are `Nat`s. For example, for<br>  ```<br>  x : Tensor [5, 6] S32<br>  x = fromLiteral [<br>        [ 0,  1,  2,  3,  4,  5],<br>        [ 6,  7,  8,  9, 10, 11],<br>        [12, 13, 14, 15, 16, 17],<br>        [18, 19, 20, 21, 22, 23],<br>        [24, 25, 26, 27, 28, 29]<br>      ]<br>  ```<br>  we can index as `slice [at 1] x` to get<br>  ```<br>  x : Tensor [6] S32<br>  x = fromLiteral [6, 7, 8, 9, 10, 11]<br>  ```<br>  or we can slice as `slice [2.to 4] x` to get<br>  ```<br>  x : Tensor [2, 6] S32<br>  x = fromLiteral [<br>        [12, 13, 14, 15, 16, 17],<br>        [18, 19, 20, 21, 22, 23]<br>      ]<br>  ```<br>  Note that in `2.to 4`, the 2 is inclusive, and the 4 exclusive, so we return indices 2 and 3.<br>  <br>  **Dynamic indices**<br>  <br>  Dynamic indices are scalar `U64` values, and the API works slightly differently because we<br>  can&apos;t know the value of dynamic indices until the graph is executed. For indexing, with scalar<br>  `U64` index `i` in `slice [at i] x`, `i` is clamped to be a valid index into that dimension.<br>  For example, for `i = fromLiteral 1`, `slice [at i] x` is<br>  ```<br>  x : Tensor [6] S32<br>  x = fromLiteral [6, 7, 8, 9, 10, 11]<br>  ```<br>  as in the static case. However, for `i = fromLiteral 10`, `slice [at i] x` returns the last row<br>  ```<br>  x : Tensor [6] S32<br>  x = fromLiteral [24, 25, 26, 27, 28, 29]<br>  ```<br>  We can also slice by specifying a scalar `U64` start index, and a static size, as<br>  `slice [i.size 2] x` with `i = fromLiteral 2` to get<br>  ```<br>  x : Tensor [2, 6] S32<br>  x = fromLiteral [<br>        [12, 13, 14, 15, 16, 17],<br>        [18, 19, 20, 21, 22, 23]<br>      ]<br>  ```<br>  For a given slice `size`, the dynamic start index is clamped such that we always get `size`<br>  elements along that axis. For example, `slice [i.size 2] x` with `i = fromLiteral 4` is<br>  ```<br>  x : Tensor [2, 6] S32<br>  x = fromLiteral [<br>        [18, 19, 20, 21, 22, 23],<br>        [24, 25, 26, 27, 28, 29]<br>      ]<br>  ```<br>  which starts at index 3 rather than index 4.<br>  <br>  **Mixed static, dynamic, slicing and indexing**<br>  <br>  Each axis can only be sliced or indexed, and must use only static or dynamic indices. However,<br>  across axes, we can mix these four arbitrarily. For example, with `slice [2.to 4, at 1] x` to<br>  get<br>  ```<br>  x : Tensor [2] S32<br>  x = fromLiteral [13, 19]<br>  ```<br>  or with `i = fromLiteral 2` in `slice [at 1, i.size 2] x` to get<br>  ```<br>  x : Tensor [2] S32<br>  x = fromLiteral [7, 8]<br>  ```<br>  <br>  Slices and indices apply to the leading axes of the tensor. For trailing axes omitted from the<br>  multi-dimensional slice, the whole of the axis is returned. If we want to slice or index over<br>  later axes and retain all indices in a leading axis, we can use the convenience function `all`,<br>  as `slice [all, at 3] x` to get<br>  ```<br>  x : Tensor [5] S32<br>  x = fromLiteral [[3], [9], [15], [21], [27]]<br>  ```<br>  This is exactly the same as the more manual `slice [0.to 5, at 3] x` and<br>  `slice [(fromLiteral 0).size 5, at 3] x`.<br>  <br>  @at The multi-dimensional slices and indices at which to slice the tensor.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.concat"><code><a class="type" href="Tensor.html#Tensor.concat"><span class="name function">concat</span></a>&ensp;:&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">axis</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">s</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">s&apos;</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">inBounds</span>&ensp;:&ensp;(<span class="type resolved" title="Data.List.InBounds"><span class="name type">InBounds</span></span>&ensp;<span class="boundvar">axis</span>&ensp;<span class="boundvar">s</span>,&ensp;<span class="type resolved" title="Data.List.InBounds"><span class="name type">InBounds</span></span>&ensp;<span class="boundvar">axis</span>&ensp;<span class="boundvar">s&apos;</span>)}&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Data.List.deleteAt"><span class="name function">deleteAt</span></span>&ensp;<span class="boundvar">axis</span>&ensp;<span class="boundvar">s</span>&ensp;<span class="keyword">=</span>&ensp;<span class="type resolved" title="Data.List.deleteAt"><span class="name function">deleteAt</span></span>&ensp;<span class="boundvar">axis</span>&ensp;<span class="boundvar">s&apos;</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;(<span class="type resolved" title="Data.List.replaceAt"><span class="name function">replaceAt</span></span>&ensp;<span class="boundvar">axis</span>&ensp;(<span class="type resolved" title="Data.List.index"><span class="name function">index</span></span>&ensp;<span class="boundvar">axis</span>&ensp;<span class="boundvar">s</span>&ensp;<span class="type resolved" title="Prelude.Num.+"><span class="name function">+</span></span>&ensp;<span class="type resolved" title="Data.List.index"><span class="name function">index</span></span>&ensp;<span class="boundvar">axis</span>&ensp;<span class="boundvar">s&apos;</span>)&ensp;<span class="boundvar">s</span>)&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Concatenate two `Tensor`s along the specfied `axis`. For example,<br>  `concat 0 (fromLiteral [[1, 2], [3, 4]]) (fromLiteral [[5, 6]])` and<br>  `concat 1 (fromLiteral [[3], [6]]) fromLiteral ([[4, 5], [7, 8]])` are both<br>  `fromLiteral [[1, 2], [3, 4], [5, 6]]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.diag"><code><a class="type" href="Tensor.html#Tensor.diag"><span class="name function">diag</span></a>&ensp;:&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">n</span>,&ensp;<span class="boundvar">n</span>]&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">n</span>]&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  The diagonal of a matrix as a vector. For example, for<br>  ```<br>  x : Tensor [3, 3] S32<br>  x = fromLiteral [[0, 1, 2],<br>                   [3, 4, 5],<br>                   [6, 7, 8]]<br>  ```<br>  `diag x` is `fromLiteral [0, 4, 8]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.Triangle"><code><span class="keyword">data</span>&ensp;<a class="type" href="Tensor.html#Tensor.Triangle"><span class="name type">Triangle</span></a>&ensp;:&ensp;<span class="name type">Type</span></code></dt><dd><pre>  Represents the upper- or lower-trinagular component of a matrix.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Constructors</b>:<br><dl class="decls">  <dt id="Tensor.Upper"><code><a class="type" href="Tensor.html#Tensor.Upper"><span class="name constructor">Upper</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Triangle"><span class="name type">Triangle</span></a></code></dt>  <dt id="Tensor.Lower"><code><a class="type" href="Tensor.html#Tensor.Lower"><span class="name constructor">Lower</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Triangle"><span class="name type">Triangle</span></a></code></dt></dl></dd><dt id="Tensor.triangle"><code><a class="type" href="Tensor.html#Tensor.triangle"><span class="name function">triangle</span></a>&ensp;:&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Triangle"><span class="name type">Triangle</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">n</span>,&ensp;<span class="boundvar">n</span>]&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">n</span>,&ensp;<span class="boundvar">n</span>]&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Get the upper- or lower-triangular component of a matrix. For example, for<br>  ```<br>  x : Tensor [3, 3] S32<br>  x = fromLiteral [[1, 2, 3],<br>                   [4, 5, 6],<br>                   [7, 8, 9]]<br>  ```<br>  `triangle Lower x` is<br>  ```<br>  x : Tensor [3, 3] S32<br>  x = fromLiteral [[1, 0, 0],<br>                   [4, 5, 0],<br>                   [7, 8, 9]]<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.(.T)"><code><a class="type" href="Tensor.html#Tensor.(.T)"><span class="name function">.T</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">m</span>,&ensp;<span class="boundvar">n</span>]&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">n</span>,&ensp;<span class="boundvar">m</span>]&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Tranpose a matrix. For example, `(fromLiteral [[1, 2], [3, 4]]).T` is<br>  `fromLiteral [[1, 3], [2, 4]]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.transpose"><code><a class="type" href="Tensor.html#Tensor.transpose"><span class="name function">transpose</span></a>&ensp;:&ensp;(<span class="boundvar">ordering</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.List.length"><span class="name function">length</span></span>&ensp;<span class="boundvar">ordering</span>&ensp;<span class="keyword">=</span>&ensp;<span class="type resolved" title="Prelude.Types.List.length"><span class="name function">length</span></span>&ensp;<span class="boundvar">shape</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Util.List.Sorted"><span class="name type">Sorted</span></span>&ensp;<a class="type" href="Util.html#Util.Neq"><span class="name function">Neq</span></a>&ensp;<span class="boundvar">ordering</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">inBounds</span>&ensp;:&ensp;<span class="type resolved" title="Data.List.Quantifiers.All.All"><span class="name type">All</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.flip"><span class="name function">flip</span></span>&ensp;<span class="type resolved" title="Data.List.InBounds"><span class="name type">InBounds</span></span>&ensp;<span class="boundvar">shape</span>)&ensp;<span class="boundvar">ordering</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;(<span class="type resolved" title="Util.List.All.map"><span class="name function">map</span></span>&ensp;(<a class="type" href="Util.html#Util.dflip"><span class="name function">dflip</span></a>&ensp;<span class="type resolved" title="Data.List.index"><span class="name function">index</span></span>&ensp;<span class="boundvar">shape</span>)&ensp;<span class="boundvar">ordering</span>)&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Transpose axes of a tensor. This is a more general version of `(.T)`, in which you can transpose<br>  any number of axes in a tensor of arbitrary rank. The i&apos;th axis in the resulting tensor<br>  corresponds to the `index i ordering`&apos;th axis in the input tensor. For example, for<br>  ```<br>  x : Tensor [2, 3, 4] S32<br>  x = fromLiteral [[[ 0,  1,  2,  3],<br>                    [ 4,  5,  6,  7],<br>                    [ 8,  9, 10, 11]],<br>                   [[12, 13, 14, 15],<br>                    [16, 17, 18, 19],<br>                    [20, 21, 22, 23]]]<br>  ```<br>  `transpose [0, 2, 1]` is<br>  ```<br>  x : Tensor [2, 4, 3] S32<br>  x = fromLiteral [[[ 0,  4,  8],<br>                    [ 1,  5,  9],<br>                    [ 2,  6, 10],<br>                    [ 3,  7, 11]],<br>                   [[12, 16, 20],<br>                    [13, 17, 21],<br>                    [14, 18, 22],<br>                    [15, 19, 23]]]<br>  ```<br>  `transpose [2, 0, 1]` is<br>  ```<br>  x : Tensor [4, 2, 3] S32<br>  x = fromLiteral [[[ 0,  4,  8],<br>                    [12, 16, 20]],<br>                   [[ 1,  5,  9],<br>                    [13, 17, 21]],<br>                   [[ 2,  6, 10],<br>                    [14, 18, 22]],<br>                   [[ 3,  7, 11],<br>                    [15, 19, 23]]]<br>  ```<br>  <br>  In order to see what effect transposing a tensor has, it can help to bear in mind the following:<br>  * if an element can be found with `slice [at 3, at 4, at 5] x` in the original tensor,<br>    that same element can instead be found with `slice [at 5, at 3, at 4]` given a<br>    `transpose [2, 0, 1]`. That is, transposing axes re-orders indices when indexing.<br>  * with `transpose [2, 0, 1]`, traversing the first axis in the result is equivalent to<br>    traversing the last axis in the input. Similarly, traversing the last axis in the result is<br>    equivalent to traversing the second axis in the input.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.identity"><code><a class="type" href="Tensor.html#Tensor.identity"><span class="name function">identity</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Num"><span class="name type">Num</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">n</span>,&ensp;<span class="boundvar">n</span>]&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  The identity tensor, with inferred shape and element type. For example,<br>  ```<br>  x : Tensor [2, 2] S32<br>  x = identity<br>  ```<br>  is<br>  ```<br>  x : Tensor [2, 2] S32<br>  x = [[1, 0],<br>       [0, 1]]<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.DimBroadcastable"><code><span class="keyword">data</span>&ensp;<a class="type" href="Tensor.html#Tensor.DimBroadcastable"><span class="name type">DimBroadcastable</span></a>&ensp;:&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  A `DimBroadcastable from to` proves that a dimension of size `from` can be broadcast to a<br>  dimension of size `to`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Constructors</b>:<br><dl class="decls">  <dt id="Tensor.Same"><code><a class="type" href="Tensor.html#Tensor.Same"><span class="name constructor">Same</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.DimBroadcastable"><span class="name type">DimBroadcastable</span></a>&ensp;<span class="boundvar">x</span>&ensp;<span class="boundvar">x</span></code></dt><dd><pre>  Proof that any dimension can be broadcast to itself. For example in shapes `[2, 3]` to<br>  `[2, 3]`.</pre></dd>  <dt id="Tensor.Stack"><code><a class="type" href="Tensor.html#Tensor.Stack"><span class="name constructor">Stack</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.DimBroadcastable"><span class="name type">DimBroadcastable</span></a>&ensp;<span class="name constructor">1</span>&ensp;<span class="boundvar">{_:4684}</span></code></dt><dd><pre>  Proof that a dimension of length one can be broadcast to any size. For example in shapes<br>  `[2, 1]` to `[2, 3]`</pre></dd>  <dt id="Tensor.Zero"><code><a class="type" href="Tensor.html#Tensor.Zero"><span class="name constructor">Zero</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.DimBroadcastable"><span class="name type">DimBroadcastable</span></a>&ensp;<span class="boundvar">{_:4690}</span>&ensp;<span class="name constructor">0</span></code></dt><dd><pre>  Proof that any dimension can be broadcast to zero. For example in shapes `[2, 3]` to `[2, 0]`.</pre></dd></dl></dd><dt id="Tensor.Broadcastable.Broadcastable"><code><span class="keyword">data</span>&ensp;<span class="type resolved" title="Tensor.Broadcastable.Broadcastable"><span class="name type">Broadcastable</span></span>&ensp;:&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<a class="type" href="Types.html#Types.Shape"><span class="name function">Shape</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<a class="type" href="Types.html#Types.Shape"><span class="name function">Shape</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  A `Broadcastable from to` constitutes proof that the shape `from` can be broadcast to the<br>  shape `to`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Constructors</b>:<br><dl class="decls">  <dt id="Tensor.Broadcastable.Same"><code><span class="type resolved" title="Tensor.Broadcastable.Same"><span class="name constructor">Same</span></span>&ensp;:&ensp;<span class="type resolved" title="Tensor.Broadcastable.Broadcastable"><span class="name type">Broadcastable</span></span>&ensp;<span class="boundvar">x</span>&ensp;<span class="boundvar">x</span></code></dt><dd><pre>  Proof that a shape can be broadcast to itself. For example:<br>  <br>  [] to []<br>  [3, 4] to [3, 4]<br>  <br>  Implementation note: we could have used `Broadcast [] []`, which would have resulted in more<br>  atomic constructors for `Broadcastable`, but the author guesses that this implementation helps<br>  the type checker avoid applications of `Match`.</pre></dd>  <dt id="Tensor.Broadcastable.Match"><code><span class="type resolved" title="Tensor.Broadcastable.Match"><span class="name constructor">Match</span></span>&ensp;:&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.List.length"><span class="name function">length</span></span>&ensp;<span class="boundvar">from</span>&ensp;<span class="keyword">=</span>&ensp;<span class="type resolved" title="Prelude.Types.List.length"><span class="name function">length</span></span>&ensp;<span class="boundvar">to</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.DimBroadcastable"><span class="name type">DimBroadcastable</span></a>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">t</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Tensor.Broadcastable.Broadcastable"><span class="name type">Broadcastable</span></span>&ensp;<span class="boundvar">from</span>&ensp;<span class="boundvar">to</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Tensor.Broadcastable.Broadcastable"><span class="name type">Broadcastable</span></span>&ensp;(<span class="boundvar">f</span>&ensp;<span class="type resolved" title="Prelude.Basics.::"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">from</span>)&ensp;(<span class="boundvar">t</span>&ensp;<span class="type resolved" title="Prelude.Basics.::"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">to</span>)</code></dt><dd><pre>  Proof that a dimension of size `f` can be broadcast to size `t` if these dimensions<br>  are `DimBroadcastable f t`. For example:<br>  <br>  [2, 3] to [2, 3]<br>  [2, 1] to [2, 3]<br>  [2, 1] to [2, 0]</pre></dd>  <dt id="Tensor.Broadcastable.Nest"><code><span class="type resolved" title="Tensor.Broadcastable.Nest"><span class="name constructor">Nest</span></span>&ensp;:&ensp;<span class="type resolved" title="Tensor.Broadcastable.Broadcastable"><span class="name type">Broadcastable</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">t</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Tensor.Broadcastable.Broadcastable"><span class="name type">Broadcastable</span></span>&ensp;<span class="boundvar">f</span>&ensp;(<span class="boundvar">{_:4741}</span>&ensp;<span class="type resolved" title="Prelude.Basics.::"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">t</span>)</code></dt><dd><pre>  Proof that broadcasting can add outer dimensions i.e. nesting. For example:<br>  <br>  [3] to [1, 3]<br>  [3] to [5, 3]</pre></dd></dl><br>  <b>Hint</b>:&ensp;<dl class="decls"><dt id="$resolved590"><code>(<span class="boundvar">to</span>&ensp;:&ensp;<a class="type" href="Types.html#Types.Shape"><span class="name function">Shape</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Tensor.Broadcastable.Broadcastable"><span class="name type">Broadcastable</span></span>&ensp;[]&ensp;<span class="boundvar">to</span></code></dt></dl></dd><dt id="Tensor.broadcast"><code><a class="type" href="Tensor.html#Tensor.broadcast"><span class="name function">broadcast</span></a>&ensp;:&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Tensor.Broadcastable.Broadcastable"><span class="name type">Broadcastable</span></span>&ensp;<span class="boundvar">from</span>&ensp;<span class="boundvar">to</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">from</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">to</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Broadcast a `Tensor` to a new compatible shape. For example,<br>  <br>  ```idris<br>  x : Tensor [2, 3] S32<br>  x = broadcast (fromLiteral [4, 5, 6])<br>  ```<br>  <br>  is<br>  <br>  ```idris<br>  x : Tensor [2, 3] S32<br>  x = fromLiteral [[4, 5, 6], [4, 5, 6]]<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.scalarToAnyOk"><code><a class="type" href="Tensor.html#Tensor.scalarToAnyOk"><span class="name function">scalarToAnyOk</span></a>&ensp;:&ensp;(<span class="boundvar">to</span>&ensp;:&ensp;<a class="type" href="Types.html#Types.Shape"><span class="name function">Shape</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Tensor.Broadcastable.Broadcastable"><span class="name type">Broadcastable</span></span>&ensp;[]&ensp;<span class="boundvar">to</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.fill"><code><a class="type" href="Tensor.html#Tensor.fill"><span class="name function">fill</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.PrimitiveRW"><span class="name type">PrimitiveRW</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="boundvar">ty</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">ty</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  A `Tensor` where every element has the specified value. For example,<br>  <br>  ```idris<br>  fives : Tensor [2, 3] S32<br>  fives = fill 5<br>  ```<br>  is<br>  ```idris<br>  fives : Tensor [2, 3] S32<br>  fives = fromLiteral [[5, 5, 5], [5, 5, 5]]<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.map"><code><a class="type" href="Tensor.html#Tensor.map"><span class="name function">map</span></a>&ensp;:&ensp;(<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">a</span>,&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">=&gt;</span>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">b</span></code></dt><dd><pre>  Lift a unary function on scalars to an element-wise function on `Tensor`s of arbitrary shape.<br>  For example,<br>  ```idris<br>  recip : Tensor [] F64 -&gt; Tensor [] F64<br>  recip = (1.0 /)<br>  ```<br>  can be lifted to an element-wise reciprocal function as `map recip (fromLiteral [-2, 0.4])`,<br>  which is `fromLiteral [-0.5, 2.5]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.map2"><code><a class="type" href="Tensor.html#Tensor.map2"><span class="name function">map2</span></a>&ensp;:&ensp;(<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">a</span>,&ensp;(<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">b</span>,&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">c</span>))&ensp;<span class="keyword">=&gt;</span>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<span class="boundvar">c</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">c</span></code></dt><dd><pre>  Lift a binary function on scalars to an element-wise function on `Tensor`s of arbitrary shape.<br>  For example,<br>  ```idris<br>  addRecip : Tensor [] F64 -&gt; Tensor [] F64 -&gt; Tensor [] F64<br>  addRecip x y = x + 1.0 / y<br>  ```<br>  can be lifted to an element-wise function as<br>  `map2 addRecip (fromLiteral [3.0, -3.0]) (fromLiteral [-2.0, 0.4])`, which is<br>  `fromLiteral [2.5, -0.5]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.reduce"><code><a class="type" href="Tensor.html#Tensor.reduce"><span class="name function">reduce</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Interfaces.Monoid"><span class="name type">Monoid</span></span>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<span class="boundvar">dtype</span>)&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">axes</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">axesUnique</span>&ensp;:&ensp;<span class="type resolved" title="Util.List.Sorted"><span class="name type">Sorted</span></span>&ensp;<span class="type resolved" title="Data.Nat.LT"><span class="name function">LT</span></span>&ensp;<span class="boundvar">axes</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">axesInBounds</span>&ensp;:&ensp;<span class="type resolved" title="Data.List.Quantifiers.All.All"><span class="name type">All</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.flip"><span class="name function">flip</span></span>&ensp;<span class="type resolved" title="Data.List.InBounds"><span class="name type">InBounds</span></span>&ensp;<span class="boundvar">shape</span>)&ensp;<span class="boundvar">axes</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;(<span class="type resolved" title="Util.List.deleteAt"><span class="name function">deleteAt</span></span>&ensp;<span class="boundvar">axes</span>&ensp;<span class="boundvar">shape</span>)&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Reduce elements along one `axis` of a `Tensor` according to a specified `reducer` `Monoid`.<br>  For example, if `x = fromLiteral [[0, 1, 2], [3, 4, 5]]`, then reduce @{Sum} 0 x` is<br>  `fromLiteral [3, 5, 7]` and `reduce @{Sum} 1 x` to `fromLiteral [3, 12]`.<br>  <br>  @reducer How to reduce elements along the given `axis`.<br>  @axis The axis along which to reduce elements.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.sort"><code><a class="type" href="Tensor.html#Tensor.sort"><span class="name function">sort</span></a>&ensp;:&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">dimension</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Data.List.InBounds"><span class="name type">InBounds</span></span>&ensp;<span class="boundvar">dimension</span>&ensp;<span class="boundvar">shape</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Sort the elements of a `Tensor` along a specified `dimension` according to a scalar-wise<br>  ordering. For sorting function `f`, elements are sorted such that for consecutive sorted<br>  elements `a` and `b`, either `f a b` is true, or `f a b` *and* `f b a` are false.<br>  <br>  **Note:** Sorting is not stable, meaning elements that compare equal according the ordering may<br>  be sorted in a different order to the order they appear in the input.<br>  <br>  For example, for `x = fromLiteral [[1, 6, 4], [3, 2, 5]]`, `sort (&lt;) 0 x` is<br>  `fromLiteral [[1, 2, 4], [3, 6, 5]]` and `sort (&lt;) 1 x` is `fromLiteral [[1, 4, 6], [2, 3, 5]]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.reverse"><code><a class="type" href="Tensor.html#Tensor.reverse"><span class="name function">reverse</span></a>&ensp;:&ensp;(<span class="boundvar">axes</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Util.List.Sorted"><span class="name type">Sorted</span></span>&ensp;<span class="type resolved" title="Data.Nat.LT"><span class="name function">LT</span></span>&ensp;<span class="boundvar">axes</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Data.List.Quantifiers.All.All"><span class="name type">All</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.flip"><span class="name function">flip</span></span>&ensp;<span class="type resolved" title="Data.List.InBounds"><span class="name type">InBounds</span></span>&ensp;<span class="boundvar">shape</span>)&ensp;<span class="boundvar">axes</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Reverse elements along the specified axes. For example, for<br>  ```<br>  x : Tensor [2, 3] S32<br>  x = fromLiteral [[-2, -1,  0],<br>                   [ 1,  2,  3]]<br>  ```<br>  `reverse [0] x` is<br>  ```<br>  x : Tensor [2, 3] S32<br>  x = fromLiteral [[ 1,  2,  3],<br>                   [-2, -1,  0]]<br>  ```<br>  `reverse [1] x` is<br>  ```<br>  x : Tensor [2, 3] S32<br>  x = fromLiteral [[ 0, -1, -2],<br>                   [ 3,  2,  1]]<br>  ```<br>  and `reverse [0, 1] x` is<br>  ```<br>  x : Tensor [2, 3] S32<br>  x = fromLiteral [[ 3,  2,  1],<br>                   [ 0, -1, -2]]<br>  ```<br>  <br>  **Note:** This function requires `axes` is ordered simply so that elements are unique.<br>  The ordering itself is irrelevant to the implementation, but ensures uniqueness without using<br>  proofs of contradiction that can be difficult for Idris to construct.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.=="><code><a class="type" href="Tensor.html#Tensor.=="><span class="name function">(==)</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Eq"><span class="name type">Eq</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a></code></dt><dd><pre>  `fromLiteral [True, False]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infix&ensp;operator,&ensp;level&ensp;6</dd><dt id="Tensor./="><code><a class="type" href="Tensor.html#Tensor./="><span class="name function">(/=)</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Eq"><span class="name type">Eq</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a></code></dt><dd><pre>  Element-wise inequality. For example, `fromLiteral [1, 2] /= fromLiteral [1, 3]` is<br>  `fromLiteral [False, True]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infix&ensp;operator,&ensp;level&ensp;6</dd><dt id="Tensor.&lt;"><code><a class="type" href="Tensor.html#Tensor.&lt;"><span class="name function">(<)</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Ord"><span class="name type">Ord</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a></code></dt><dd><pre>  Element-wise less than. For example, `fromLiteral [1, 2, 3] &lt; fromLiteral [2, 2, 2]` is<br>  `fromLiteral [True, False, False]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infix&ensp;operator,&ensp;level&ensp;6</dd><dt id="Tensor.&gt;"><code><a class="type" href="Tensor.html#Tensor.&gt;"><span class="name function">(>)</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Ord"><span class="name type">Ord</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a></code></dt><dd><pre>  Element-wise greater than. For example, `fromLiteral [1, 2, 3] &gt; fromLiteral [2, 2, 2]` is<br>  `fromLiteral [False, False, True]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infix&ensp;operator,&ensp;level&ensp;6</dd><dt id="Tensor.&lt;="><code><a class="type" href="Tensor.html#Tensor.&lt;="><span class="name function">(&lt;=)</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Ord"><span class="name type">Ord</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a></code></dt><dd><pre>  Element-wise less than or equal. For example, `fromLiteral [1, 2, 3] &lt;= fromLiteral [2, 2, 2]`<br>  is `fromLiteral [True, True, False]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infix&ensp;operator,&ensp;level&ensp;6</dd><dt id="Tensor.&gt;="><code><a class="type" href="Tensor.html#Tensor.&gt;="><span class="name function">(&gt;=)</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Ord"><span class="name type">Ord</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a></code></dt><dd><pre>  Element-wise greater than or equal. For example,<br>  `fromLiteral [1, 2, 3] &gt;= fromLiteral [2, 2, 2]` is `fromLiteral [False, True, True]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infix&ensp;operator,&ensp;level&ensp;6</dd><dt id="Tensor.&amp;&amp;"><code><a class="type" href="Tensor.html#Tensor.&amp;&amp;"><span class="name function">(&amp;&amp;)</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a></code></dt><dd><pre>  Element-wise boolean and. For example,<br>  `fromLiteral [True, True, False, False] &amp;&amp; fromLiteral [True, False, True, False]` is<br>  `fromLiteral [True, False, False, False]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infixr&ensp;operator,&ensp;level&ensp;5</dd><dt id="Tensor.||"><code><a class="type" href="Tensor.html#Tensor.||"><span class="name function">(||)</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a></code></dt><dd><pre>  Element-wise boolean or. For example,<br>  `fromLiteral [True, True, False, False] || fromLiteral [True, False, True, False]` is<br>  `fromLiteral [True, True, True, False]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infixr&ensp;operator,&ensp;level&ensp;4</dd><dt id="Tensor.not"><code><a class="type" href="Tensor.html#Tensor.not"><span class="name function">not</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a></code></dt><dd><pre>  Element-wise boolean negation. For example, `not (fromLiteral [True, False])` is<br>  `fromLiteral [False, True]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.select"><code><a class="type" href="Tensor.html#Tensor.select"><span class="name function">select</span></a>&ensp;:&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Choose elements from two `Tensor`s based on a `Tensor` of predicates. For each element in the<br>  predicates, the output will use the corresponding element from `onTrue` if the element is<br>  truthy, else the element from `onFalse`. For example, for<br>  ```<br>  preds : Tensor [3] PRED<br>  preds = fromLiteral [False, True, False]<br>  <br>  onTrue : Tensor [3] S32<br>  onTrue = fromLiteral [1, 2, 3]<br>  <br>  onFalse : Tensor [3] S32<br>  onFalse = fromLiteral [4, 5, 6]<br>  ```<br>  `select preds onTrue onFalse` is `fromLiteral [4, 2, 6]`.<br>  <br>  @onTrue The elements to choose where the predicate elements are truthy.<br>  @onFalse The elements to choose where the predicate elements are falsy.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.cond"><code><a class="type" href="Tensor.html#Tensor.cond"><span class="name function">cond</span></a>&ensp;:&ensp;(<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">tt</span>,&ensp;(<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">ft</span>,&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">dtype</span>))&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.PRED"><span class="name type">PRED</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">ts</span>&ensp;<span class="boundvar">tt</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">ts</span>&ensp;<span class="boundvar">tt</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">fs</span>&ensp;<span class="boundvar">ft</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">fs</span>&ensp;<span class="boundvar">ft</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Use a scalar predicate to choose which of two functions to evaluate. If the predicte is truthy,<br>  evaluate `onTrue` on the corresponding specified argument, otherwise evaluate `onFalse` on the<br>  corresponding specified argument. The result of the evaluated function is returned. For example,<br>  for<br>  ```<br>  x : Tensor [2] S32<br>  x = fromLiteral [2, -1]<br>  <br>  y : Tensor [2, 2] S32<br>  y = fromLiteral [[5, 6],<br>                   [7, 8]]<br>  ```<br>  `cond (fromLiteral True) (fromLiteral 2 *) x diag y` is `fromLiteral [4, -2]` and<br>  `cond (fromLiteral False) (fromLiteral 2 *) x diag y` to `fromLiteral [5, 8]`.<br>  <br>  While both functions will be called for the purposes of defining the computation, only one will<br>  be evaluated with its specified argument. That is, this function short-circuits.<br>  <br>  @onTrue The function to execute if the predicate is truthy.<br>  @onFalse The function to execute if the predicate is falsy.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.Vector.@@"><code><span class="type resolved" title="Tensor.Vector.@@"><span class="name function">(@@)</span></span>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Num"><span class="name type">Num</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">m</span>]&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">m</span>]&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Vector dot product with a tensor of any rank. The vector dot product is with the first axis of<br>  the right-hand side tensor. For example `fromLiteral [0, 1, 2] @@ fromLiteral [-1, -3, -1]` is<br>  `-1`.<br>  <br>  **WARNING** Not well tested</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infixl&ensp;operator,&ensp;level&ensp;9</dd><dt id="Tensor.Matrix.@@"><code><span class="type resolved" title="Tensor.Matrix.@@"><span class="name function">(@@)</span></span>&ensp;:&ensp;(<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.Primitive"><span class="name type">Primitive</span></a>&ensp;<span class="boundvar">dtype</span>,&ensp;<a class="type" href="Primitive.html#Primitive.Num"><span class="name type">Num</span></a>&ensp;<span class="boundvar">dtype</span>)&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">n</span>,&ensp;<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">m</span>]&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;(<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">m</span>&ensp;<span class="type resolved" title="Prelude.Basics.::"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">tl</span>)&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Data.Nat.LTE"><span class="name type">LTE</span></span>&ensp;(<span class="type resolved" title="Prelude.Types.List.length"><span class="name function">length</span></span>&ensp;<span class="boundvar">tl</span>)&ensp;<span class="name constructor">1</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;(<span class="boundvar">n</span>&ensp;<span class="type resolved" title="Prelude.Basics.::"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">tl</span>)&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Matrix multiplication with a matrix or vector. Contraction is along the last axis of the first<br>  and the first axis of the last. For example:<br>  <br>  ```idris<br>  x : Tensor [2, 3] S32<br>  x = fromLiteral [[-1, -2, -3], [0, 1, 2]]<br>  <br>  y : Tensor [3, 1] S32<br>  y = fromLiteral [[4, 0, 5]]<br>  <br>  z : Tensor [2, 1] S32<br>  z = x @@ y<br>  ```<br>  <br>  is<br>  <br>  ```idris<br>  z : Tensor [2, 1] S32<br>  z = fromLiteral [-19, 10]<br>  ```<br>  <br>  **WARNING** Not well tested</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infixl&ensp;operator,&ensp;level&ensp;9</dd><dt id="Tensor.+"><code><a class="type" href="Tensor.html#Tensor.+"><span class="name function">(+)</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Num"><span class="name type">Num</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Element-wise addition. For example, `fromLiteral [1, 2] + fromLiteral [3, 4]` is<br>  `fromLiteral [4, 6]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infixl&ensp;operator,&ensp;level&ensp;8</dd><dt id="Tensor.negate"><code><a class="type" href="Tensor.html#Tensor.negate"><span class="name function">negate</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Neg"><span class="name type">Neg</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Element-wise negation. For example, `- fromLiteral [1, -2]` is `fromLiteral [-1, 2]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;prefix operator, level&ensp;10</dd><dt id="Prelude.Num.negate"><code><span class="type resolved" title="Prelude.Num.negate"><span class="name function">negate</span></span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Num.Neg"><span class="name type">Neg</span></span>&ensp;<span class="boundvar">ty</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">ty</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">ty</span></code></dt><dd><pre>  The underlying of unary minus. `-5` desugars to `negate (fromInteger 5)`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Fixity Declaration</b>:&ensp;prefix operator, level&ensp;10</dd><dt id="Tensor.-"><code><a class="type" href="Tensor.html#Tensor.-"><span class="name function">(-)</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Neg"><span class="name type">Neg</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Element-wise subtraction. For example, `fromLiteral [3, 4] - fromLiteral [4, 2]` is<br>  `fromLiteral [-1, 2]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declarations</b>:<br>  infixl&ensp;operator,&ensp;level&ensp;8<br>prefix operator, level&ensp;10</dd><dt id="Tensor.*"><code><a class="type" href="Tensor.html#Tensor.*"><span class="name function">(*)</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Num"><span class="name type">Num</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Element-wise multiplication. For example, `fromLiteral [2, 3] * fromLiteral [4, 5]` is<br>  `fromLiteral [8, 15]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infixl&ensp;operator,&ensp;level&ensp;9</dd><dt id="Tensor.Scalarwise.*"><code><span class="type resolved" title="Tensor.Scalarwise.*"><span class="name function">(*)</span></span>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Num"><span class="name type">Num</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;(<span class="boundvar">d</span>&ensp;<span class="type resolved" title="Prelude.Basics.::"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">ds</span>)&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;(<span class="boundvar">d</span>&ensp;<span class="type resolved" title="Prelude.Basics.::"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">ds</span>)&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Multiplication by a scalar. For example, `fromLiteral 2 * fromLiteral [3, 5]` is<br>  `fromLiteral [6, 10]`.<br>  <br>  The RHS is required to be non-scalar simply to avoid ambiguities with element-wise `(*)`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infixl&ensp;operator,&ensp;level&ensp;9</dd><dt id="Tensor./"><code><a class="type" href="Tensor.html#Tensor./"><span class="name function">(/)</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Fractional"><span class="name type">Fractional</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Element-wise floating point division. For example, `fromLiteral [2, 3] / fromLiteral [4, 5]` is<br>  `fromLiteral [0.5, 0.6]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infixl&ensp;operator,&ensp;level&ensp;9</dd><dt id="Tensor.Scalarwise./"><code><span class="type resolved" title="Tensor.Scalarwise./"><span class="name function">(/)</span></span>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Fractional"><span class="name type">Fractional</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;(<span class="boundvar">d</span>&ensp;<span class="type resolved" title="Prelude.Basics.::"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">ds</span>)&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;(<span class="boundvar">d</span>&ensp;<span class="type resolved" title="Prelude.Basics.::"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">ds</span>)&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Floating point division by a scalar. For example, `fromLiteral [3.4, -5.6] / fromLiteral 2` is<br>  `fromLiteral [1.7, -2.8]`.<br>  <br>  The LHS is required to be non-scalar simply to avoid ambiguities with element-wise `(/)`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infixl&ensp;operator,&ensp;level&ensp;9</dd><dt id="Tensor.recip"><code><a class="type" href="Tensor.html#Tensor.recip"><span class="name function">recip</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The element-wise reciprocal. For example, `recip (fromLiteral [-2, 0, 0.2])`<br>  is `fromLiteral [-0.5, nan, 5]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.^"><code><a class="type" href="Tensor.html#Tensor.^"><span class="name function">(^)</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  Each element in `base` raised to the power of the corresponding element in `exponent`.<br>  example, `fromLiteral [2, 25, -9] ^ fromLiteral [3, -0.5, 0.5]` is `fromLiteral [8, 0.2, nan]`.<br>  <br>  Note: The behaviour of this function is not well-defined at negative or positive infinity, or<br>    NaN.<br>  <br>  Note: The first root is used.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infixr&ensp;operator,&ensp;level&ensp;9</dd><dt id="Tensor.abs"><code><a class="type" href="Tensor.html#Tensor.abs"><span class="name function">abs</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Abs"><span class="name type">Abs</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Element-wise absolute value. For example, `abs (fromLiteral [-2, 3])` is<br>  `fromLiteral [2, 3]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.exp"><code><a class="type" href="Tensor.html#Tensor.exp"><span class="name function">exp</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The element-wise natural exponential. For example, `exp (fromLiteral [-1, 0, 2])` is<br>  `fromLiteral [1 / euler, 1, pow euler 2]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.floor"><code><a class="type" href="Tensor.html#Tensor.floor"><span class="name function">floor</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The element-wise floor function. For example,<br>  `floor (fromLiteral [-1.6, -1.5, -1.4, -1.0, 1.0, 1.4, 1.5, 1.6])` is<br>  `fromLiteral [-2.0, -2.0, -2.0, -1.0, 1.0, 1.0, 1.0, 1.0]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.ceil"><code><a class="type" href="Tensor.html#Tensor.ceil"><span class="name function">ceil</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The element-wise ceiling function. For example,<br>  `ceil (fromLiteral [-1.6, -1.5, -1.4, -1.0, 1.0, 1.4, 1.5, 1.6])` is<br>  `fromLiteral [-1.0, -1.0, -1.0, -1.0, 1.0, 2.0, 2.0, 2.0]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.log"><code><a class="type" href="Tensor.html#Tensor.log"><span class="name function">log</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The element-wise natural logarithm. Negative inputs yield NaN output. For example,<br>  `log (fromLiteral [1 / euler, 1, euler * euler])` is `fromLiteral [-1, 0, 2]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.logistic"><code><a class="type" href="Tensor.html#Tensor.logistic"><span class="name function">logistic</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The element-wise logistic function equivalent to `1 / 1 + exp (-x)`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.sin"><code><a class="type" href="Tensor.html#Tensor.sin"><span class="name function">sin</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The element-wise sine.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.cos"><code><a class="type" href="Tensor.html#Tensor.cos"><span class="name function">cos</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The element-wise cosine.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.tan"><code><a class="type" href="Tensor.html#Tensor.tan"><span class="name function">tan</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The element-wise tangent.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.asin"><code><a class="type" href="Tensor.html#Tensor.asin"><span class="name function">asin</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The element-wise inverse sine.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.acos"><code><a class="type" href="Tensor.html#Tensor.acos"><span class="name function">acos</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The element-wise inverse cosine.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.atan"><code><a class="type" href="Tensor.html#Tensor.atan"><span class="name function">atan</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The element-wise inverse tangent.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.sinh"><code><a class="type" href="Tensor.html#Tensor.sinh"><span class="name function">sinh</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The element-wise hyperbolic sine.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.cosh"><code><a class="type" href="Tensor.html#Tensor.cosh"><span class="name function">cosh</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The element-wise hyperbolic cosine.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.tanh"><code><a class="type" href="Tensor.html#Tensor.tanh"><span class="name function">tanh</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The element-wise hyperbolic tangent.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.asinh"><code><a class="type" href="Tensor.html#Tensor.asinh"><span class="name function">asinh</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The element-wise inverse hyperbolic sine.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.acosh"><code><a class="type" href="Tensor.html#Tensor.acosh"><span class="name function">acosh</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The element-wise inverse hyperbolic cosine.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.atanh"><code><a class="type" href="Tensor.html#Tensor.atanh"><span class="name function">atanh</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The element-wise inverse hyperbolic tangent.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.erf"><code><a class="type" href="Tensor.html#Tensor.erf"><span class="name function">erf</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  An approximation to the element-wise error function.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.square"><code><a class="type" href="Tensor.html#Tensor.square"><span class="name function">square</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The element-wise square. For example, `square (fromLiteral [-2, 0, 3])`<br>  is `fromLiteral [4, 0, 9]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.sqrt"><code><a class="type" href="Tensor.html#Tensor.sqrt"><span class="name function">sqrt</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  The element-wise square root. The first root is used. Negative inputs yield NaN output.<br>  For example, `sqrt (fromLiteral [0, 9])` is `fromLiteral [0, 3]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.min"><code><a class="type" href="Tensor.html#Tensor.min"><span class="name function">min</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Ord"><span class="name type">Ord</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  The element-wise minimum of the first argument compared to the second. For example,<br>  `min (fromLiteral [-3, -1, 3]) (fromLiteral [-1, 0, 1])` is `fromLiteral [-3, -1, 1]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.max"><code><a class="type" href="Tensor.html#Tensor.max"><span class="name function">max</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Ord"><span class="name type">Ord</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  The element-wise maximum of the first argument compared to the second. For example,<br>  `max (fromLiteral [-3, -1, 3]) (fromLiteral [-1, 0, 1])` is `fromLiteral [-1, 0, 3]`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.argmin"><code><a class="type" href="Tensor.html#Tensor.argmin"><span class="name function">argmin</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Ord"><span class="name type">Ord</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">n</span>]&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.U64"><span class="name type">U64</span></a></code></dt><dd><pre>  The first index of the minimum value in a vector. For example,<br>  `argmin (fromLiteral [-1, 3, -2, -2, 3])` is `fromLiteral 2`. If the vector contains NaN values,<br>  `argmin` returns the index of the first NaN.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.argmax"><code><a class="type" href="Tensor.html#Tensor.argmax"><span class="name function">argmax</span></a>&ensp;:&ensp;<a class="type" href="Primitive.html#Primitive.Ord"><span class="name type">Ord</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">n</span>]&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.U64"><span class="name type">U64</span></a></code></dt><dd><pre>  The first index of the maximum value in a vector. For example,<br>  `argmin (fromLiteral [-1, 3, -2, -2, 3])` is `fromLiteral 1`. If the vector contains NaN values,<br>  `argmin` returns the index of the first NaN.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.cholesky"><code><a class="type" href="Tensor.html#Tensor.cholesky"><span class="name function">cholesky</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">n</span>,&ensp;<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">n</span>]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">n</span>,&ensp;<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">n</span>]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  Cholesky decomposition. Computes the lower triangular matrix `L` from the symmetric, positive<br>  semi-definite matrix `X` s.t. `X = L @@ L.T`. Values will be NaN if the input matrix is not<br>  positive semi-definite. The remaining matrix components - those not in the lower triangle or<br>  diagonal - will always be zero.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.Matrix.|\"><code><span class="type resolved" title="Tensor.Matrix.|\"><span class="name function">(|\)</span></span>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">m</span>,&ensp;<span class="boundvar">m</span>]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">m</span>,&ensp;<span class="boundvar">n</span>]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">m</span>,&ensp;<span class="boundvar">n</span>]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  Solve the set of linear equations `a @@ x = b` for `x` where `a` is a lower-triangular matrix.<br>  `a` is given by the lower-triangular elements of the first argument. Values in the<br>  upper-triangular part are ignored. If `a` is lower-triangular already,<br>  this is written `a |\ b`.<br>  <br>  The operator is shaped like the lower-triangular portion of a matrix to signal that it uses<br>  this portion of its argument. This is in contrast to `(\|)`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infix&ensp;operator,&ensp;level&ensp;9</dd><dt id="Tensor.Matrix.\|"><code><span class="type resolved" title="Tensor.Matrix.\|"><span class="name function">(\|)</span></span>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">m</span>,&ensp;<span class="boundvar">m</span>]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">m</span>,&ensp;<span class="boundvar">n</span>]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">m</span>,&ensp;<span class="boundvar">n</span>]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  Solve the set of linear equations `a @@ x = b` for `x` where `a` is an upper-triangular<br>  matrix. `a` is given by the upper-triangular elements of the first argument. Values in the<br>  lower-triangular part are ignored. If `a` is upper-triangular already, this is written<br>  `a \| b`.<br>  <br>  The operator is shaped like the upper-triangular portion of a matrix to signal that it uses<br>  this portion of its argument. This is in contrast to `(|\)`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infix&ensp;operator,&ensp;level&ensp;9</dd><dt id="Tensor.Vector.|\"><code><span class="type resolved" title="Tensor.Vector.|\"><span class="name function">(|\)</span></span>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">m</span>,&ensp;<span class="boundvar">m</span>]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">m</span>]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">m</span>]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  Solve the set of linear equations `a @@ x = b` for `x` where `a` is a lower-triangular matrix.<br>  `a` is given by the lower-triangular elements of the first argument. Values in the<br>  upper-triangular part are ignored. If `a` is lower-triangular already,<br>  this is written `a |\ b`.<br>  <br>  The operator is shaped like the lower-triangular portion of a matrix to signal that it uses<br>  this portion of its argument. This is in contrast to `(\|)`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infix&ensp;operator,&ensp;level&ensp;9</dd><dt id="Tensor.Vector.\|"><code><span class="type resolved" title="Tensor.Vector.\|"><span class="name function">(\|)</span></span>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">m</span>,&ensp;<span class="boundvar">m</span>]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">m</span>]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="boundvar">m</span>]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a></code></dt><dd><pre>  Solve the set of linear equations `a @@ x = b` for `x` where `a` is an upper-triangular<br>  matrix. `a` is given by the upper-triangular elements of the first argument. Values in the<br>  lower-triangular part are ignored. If `a` is upper-triangular already, this is written<br>  `a \| b`.<br>  <br>  The operator is shaped like the upper-triangular portion of a matrix to signal that it uses<br>  this portion of its argument. This is in contrast to `(|\)`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infix&ensp;operator,&ensp;level&ensp;9</dd><dt id="Tensor.trace"><code><a class="type" href="Tensor.html#Tensor.trace"><span class="name function">trace</span></a>&ensp;:&ensp;(<a class="type" href="Primitive.html#Primitive.Num"><span class="name type">Num</span></a>&ensp;<span class="boundvar">dtype</span>,&ensp;<span class="type resolved" title="Prelude.Num.Num"><span class="name type">Num</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Primitive.html#Primitive.PrimitiveRW"><span class="name type">PrimitiveRW</span></a>&ensp;<span class="boundvar">dtype</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">n</span>,&ensp;<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">n</span>]&ensp;<span class="boundvar">dtype</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<span class="boundvar">dtype</span></code></dt><dd><pre>  Sum the elements along the diagonal of the input. For example,<br>  `trace (fromLiteral [[-1, 5], [1, 4]])` is `3`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.Rand"><code><a class="type" href="Tensor.html#Tensor.Rand"><span class="name function">Rand</span></a>&ensp;:&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  A `Rand a` produces a pseudo-random value of type `a` from a `Tensor [1] U64` state.<br>  The state is updated each time a new value is generated.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Tensor.uniform"><code><a class="type" href="Tensor.html#Tensor.uniform"><span class="name function">uniform</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.U64"><span class="name type">U64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Rand"><span class="name function">Rand</span></a>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>)</code></dt><dd><pre>  Generate independent and identically distributed (IID) uniform samples bounded element-wise<br>  between `bound` and `bound&apos;`.<br>  <br>  `bound` and `bound&apos;` need not be ordered, and samples will be generated, elementwise, in<br>  [min bound bound&apos;, max bound bound&apos;). The exception is where the bounds are equal, in which<br>  case: if the bounds are finite, samples are generated at the common bound, else samples are NaN.<br>  <br>  The generated samples are a deterministic function of the input key and state, but may vary<br>  between backends and library versions.<br>  <br>  Example usage, multiplying two uniform samples<br>  ```<br>  x : Tensor [3] F64<br>  x = let key = fromLiteral 2<br>          rng = uniform key (fill 0.0) (fill 1.0)<br>          initialState = fromLiteral [0]<br>       in evalState initialState [| rng * rng |]<br>  ```<br>  <br>  @key Determines the stream of generated samples.<br>  @bound A bound of the samples. See full docstring for details.<br>  @bound&apos; A bound of the samples. See full docstring for details.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Tensor.normal"><code><a class="type" href="Tensor.html#Tensor.normal"><span class="name function">normal</span></a>&ensp;:&ensp;<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;[]&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.U64"><span class="name type">U64</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Tensor.html#Tensor.Rand"><span class="name function">Rand</span></a>&ensp;(<a class="type" href="Tensor.html#Tensor.Tensor"><span class="name type">Tensor</span></a>&ensp;<span class="boundvar">shape</span>&ensp;<a class="type" href="Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.html#Compiler.Xla.TensorFlow.Compiler.Xla.XlaData.F64"><span class="name type">F64</span></a>)</code></dt><dd><pre>  Generate independent and identically distributed (IID) samples from the standard normal<br>  distribution.<br>  <br>  The generated samples are a deterministic function of the input key and state, but may vary<br>  between backends and library versions.<br>  <br>  Example usage, multiplying two normal samples<br>  ```<br>  x : Tensor [3] F64<br>  x = let key = fromLiteral 2<br>          rng = normal key<br>          initialState = fromLiteral [0]<br>       in evalState initialState [| rng * rng |]<br>  ```<br>  <br>  @key Determines the stream of generated samples.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd></dl></div><footer>Produced by Idris 2 version 0.6.0-407409fec</footer></body></html>
